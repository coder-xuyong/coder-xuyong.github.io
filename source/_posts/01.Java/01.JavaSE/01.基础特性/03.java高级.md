---
title: java 高级
categories:
  - 1.Java
  - 1.JavaSE
  - 1.基础特性
tags:
  - Java
series:
  - 基础特性
order: 3
abbrlink: 9dd42db4
date: 2025-08-30 16:16:53
---
## Java 高级

### 数据结构
数组、列表、集合、映射、栈、队列、堆、树。

### Java 集合框架
![Java 集合架构图](https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif)

| 类型 | 描述 | 特点 | 常用实现类 |
| :--- | :--- | :--- | :--- |
| **`Collection`** | 单列数据集合的根接口 | 存储一组对象的容器 | (它下面有List和Set) |
| **`List`** | **有序、可重复**的集合 | 有索引，允许重复，元素有顺序 | **`ArrayList`**, **`LinkedList`**, `Vector` |
| **`Set`** | **唯一、无序**的集合 | 不允许重复元素，不保证顺序 | **`HashSet`**, **`LinkedHashSet`**, **`TreeSet`** |
| **`Map`** | **双列数据**的集合 | 存储**键值对(Key-Value)**，Key唯一 | **`HashMap`**, **`LinkedHashMap`**, **`TreeMap`**, `Hashtable` |
| **`Collections`** | **操作集合的工具类** | 提供了一系列静态方法，用于对集合进行排序、搜索、线程安全化等操作 | (这是一个工具类，不是接口) |


**iterator**

```java
 List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
Iterator it = list.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```

**Comparator**

```java
Integer[] arr = {9, 8, 7, 2, 3, 4, 1, 0, 6, 5};
Arrays.sort(arr, new Comparator<Integer>() {
    @Override
    public int compare(Integer o1, Integer o2) {
        return o1-o2;//o1<o2,升序
    }
})
System.out.println(Arrays.toString(arr));
```

#### List
##### ArrayList
它可以动态修改数组，没有固定大小，可以删除和添加元素。
![ArrayList](https://www.runoob.com/wp-content/uploads/2020/06/ArrayList-1-768x406-1.png)

详细api方法可以查看：[官方API文档](https://docs.oracle.com/javase/8/docs/api/index.html)

##### LinkedList
链表（Linked list）是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。
链表可以分为单链表和双链表。
**与 ArrayList 相比，LinkedList 的增加和删除的操作效率更高，而查找和修改的操作效率较低。**



#### Map
##### HashMap
![HashMap](https://www.runoob.com/wp-content/uploads/2020/07/WV9wXLl.png)
存储 Key-Value 键值对数据，Key 不允许重复（重复则覆盖），Value 可以重复。
允许至多一个 null 键 和多个 null 值。


### NIO Files 
用于简化文件I/O操作

### 泛型
定义：定义类、接口、方法时，同时声明一个或者多个类型的变量
格式：`public <T> void printArray(T[] arr){...}` 或者 `public class ArrayList<T>{....}`，在 "<>" 中声明类型。
作用：在编译阶段约束所能操作的数据类型，避免强制转换出错。

> 像 `public <T> void printArray(T[] arr){...}` 定义时拥有返回值，void 就改为 T。
**泛型类型参数约定：**

| 类型参数 | 含义 | 常用场景 |
|---------|------|---------|
| `E` | Element (元素) | 在集合中使用，因为集合中存放的是元素 |
| `T` | Type (类型) | 表示一个Java类 |
| `K` | Key (键) | 在映射中表示键的类型 |
| `V` | Value (值) | 在映射中表示值的类型 |
| `N` | Number (数值类型) | 表示数值类型 |
| `?` | 通配符 | **使用泛型时**（不是定义），表示所有的Java类型 |
| `R` | Result (结果) | 表示方法返回值的类型 |
| `U`, `S` | 其他类型 | 当需要多个类型参数时使用 |

**上下限：**
- 泛型上限：? extends Car，? 必须接收 Car 或者其子类
- 泛型下限：? super Car，? 必须接收Car 或者其父类

**支持的类型：**
不支持基本数据类型，只支持对象类型（引用类型）

### 序列化
是将对象转为字节流，反序列化是将字节流重新转为对象。
要实现序列化，只需要类实现 Serializable 接口即可。
### 网络编程
主要是 socket 编程。

### 发送邮件
遇到再补充


### 多线程编程
通过实现 Runnable 接口；
通过继承 Thread 类本身；
通过 Callable 和 Future 创建线程

### Applet
嵌入 HTML 的小程序，已经过时，不必理会。
### 文档注释
后续将常用的idea文档注释添加到这里

### Java 8新特性
#### Lambda
可以替代某些**函数式接口**的内部类的对象，让代码更加简洁。
而函数式接口就是：有且只有一个抽象方法的接口。
> @FunctionalInterface 是专门给函数式接口中的注解，声明后只能有一个抽象方法。
格式：`(args)->{}`

实例：可以简化集合里面的comparator的写法,如将上文的 comparator 简写为下面：
```java
//初步省略
Arrays.sort(arr,(Integer o1, Integer o2) -> {return o1-o2});
//参数类型也可以不写
Arrays.sort(arr,(o1, o2) -> {return o1-o2});
//方法体只有一行代码时，大括号可以不写，“;”省略，如果式return语句，return也不写。
Arrays.sort(arr,(o1, o2) ->  o1-o2);
//只有一个参数时候，小括号也可以省略
btn.btn.addActionListener(e->{});
```
##### 方法引用
1. 静态方法引用
使用场景：lambda 表达式只调用了一个静态方法，并且“->”前后方法参数形式一致。
格式：类名::静态方法
```java
Arrays.sort(arr,(o1, o2) ->  orderArr(o1,o2));
//像这样的情况，orderArr 是静态方法，可以进一步简写。其中 integer 可以换成 student 中的 age 去理解
Arrays.sort(arr,Integer::orderArr)
```

2. 实例方法引用
使用场景：lambda 表达式只通过对象名调用实例方法，并且“->”前后方法参数形式一致。
格式：对象名::实例方法
```java
Arrays.sort(arr,(o1, o2) ->  obj.orderArr(o1,o2));
//简写为
Arrays.sort(arr,obj::orderArr);
```
3. 特定类的方法引用
使用场景：lambda 表达式只调用了一个特定类型的实例方法，并且前面参数列表中的第一个参数作为方法的主调，其他所有参数都是被调用方法的参数。
格式：特定类的名称::方法
```java
String[] arr = {"angel","bro","andy"};
//忽略英文大小写排序
Arrays.sort(arr,(o1, o2) ->  {
    return o1.compareToIngnoreCase(o2);
});
//使用特定类的方法引用，可以简写为
Arrays.sort(arr,String::compareToIngnoreCase)
```

4. 构造器引用
使用场景：lambda 表达式里面只创建对象，并且“->”前后方法参数形式一致。
格式：类名::new
```java
@FunctionalInterface
interface CarFactory{
    Car getCar(String name);
}
// lambda 表达式改写内部类如下
CarFactory cf = name -> new Car(name);
//使用构造器引用，改写为
CarFactory cf = Car::new;

Car ca = cf.getCar("xxx");
```
#### Stream API


### MySql 连接
1. [下载驱动 jar](https://static.jyshare.com/download/mysql-connector-java-8.0.16.jar)
2. 示例代码如下：
```java
package com.runoob.test;
 
import java.sql.*;
 
public class MySQLDemo {
 
    // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  
    static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB";
 
    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL
    //static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";  
    //static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";
 
 
    // 数据库的用户名与密码，需要根据自己的设置
    static final String USER = "root";
    static final String PASS = "123456";
 
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        try{
            // 注册 JDBC 驱动
            Class.forName(JDBC_DRIVER);
        
            // 打开链接
            System.out.println("连接数据库...");
            conn = DriverManager.getConnection(DB_URL,USER,PASS);
        
            // 执行查询
            System.out.println(" 实例化Statement对象...");
            stmt = conn.createStatement();
            String sql;
            sql = "SELECT id, name, url FROM websites";
            ResultSet rs = stmt.executeQuery(sql);
        
            // 展开结果集数据库
            while(rs.next()){
                // 通过字段检索
                int id  = rs.getInt("id");
                String name = rs.getString("name");
                String url = rs.getString("url");
    
                // 输出数据
                System.out.print("ID: " + id);
                System.out.print(", 站点名称: " + name);
                System.out.print(", 站点 URL: " + url);
                System.out.print("\n");
            }
            // 完成后关闭
            rs.close();
            stmt.close();
            conn.close();
        }catch(SQLException se){
            // 处理 JDBC 错误
            se.printStackTrace();
        }catch(Exception e){
            // 处理 Class.forName 错误
            e.printStackTrace();
        }finally{
            // 关闭资源
            try{
                if(stmt!=null) stmt.close();
            }catch(SQLException se2){
            }// 什么都不做
            try{
                if(conn!=null) conn.close();
            }catch(SQLException se){
                se.printStackTrace();
            }
        }
        System.out.println("Goodbye!");
    }
}
```

