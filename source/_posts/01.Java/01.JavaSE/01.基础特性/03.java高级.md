---
title: java 高级
categories:
  - 1.Java
  - 1.JavaSE
  - 1.基础特性
tags:
  - Java
series:
  - 基础特性
order: 3
abbrlink: 9dd42db4
date: 2025-08-30 16:16:53
---
## Java 高级



### 数据结构
数组、列表、集合、映射、栈、队列、堆、树。

### Java 集合框架
![Java 集合架构图](https://www.runoob.com/wp-content/uploads/2014/01/2243690-9cd9c896e0d512ed.gif)

[点击查看UML图](https://www.cnblogs.com/Bytezero/p/15270427.html)

| 类型 | 描述 | 特点 | 常用实现类 |
| :--- | :--- | :--- | :--- |
| **`Collection`** | 单列数据集合的根接口 | 存储一组对象的容器 | (它下面有List和Set) |
| **`List`** | **有序、可重复**的集合 | 有索引，允许重复，元素有顺序 | **`ArrayList`**, **`LinkedList`**, `Vector` |
| **`Set`** | **唯一、无序**的集合 | 无索引，不允许重复元素，不保证顺序 | **`HashSet`**（无序）, **`LinkedHashSet`**(有序), **`TreeSet`**(升序) |
| **`Map`** | **双列数据**的集合 | 存储**键值对(Key-Value)**，Key唯一，排序由key决定 | **`HashMap`**（无序）, **`LinkedHashMap`**（有序）, **`TreeMap`**（升序）, `Hashtable` |
| **`Collections`** | **操作集合的工具类** | 提供了一系列静态方法，用于对集合进行排序、搜索、线程安全化等操作 | (这是一个工具类，不是接口) |



#### 单列集合遍历

1. iterator

```java
List<Integer> list = new ArrayList<>();
list.add(1);
list.add(2);
list.add(3);
Iterator it = list.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
```
2. 增强 for 循环，可以遍历集合和数组

3. lambda 表达式 `default void forEach(Consumer<? super T> action)`
```java
arr.forEach(e -> System.out.println(1))
```

> 集合中，边遍历边增删，只能使用迭代器。

#### 双列集合遍历
1. 键找值
```java
HashMap<String,Integer> map = new HashMap();
Set<String> keys = map.keySet();
for(String key: keys){
    Integer val = map.get(key);
}
// Collection<Integer> values =map.values();
```

2. 键值对 
```java
Set< Map.Entry<string,Integer> entries = map.entryset();
for(Map.Entry<string, Integer>entry :entries){
    String key = entry.getKey();
    Integer value = entry.getValue();
    System.out.println(key +"====>" + value);
}
```

3. lambda 表达式 `default void forEach(BigConsumer<? super K,? super V> action)`
需要用到forEach方法
```java
map.forEach((k,v)->{
    // xxx
})
```
#### List
##### ArrayList

![ArrayList](https://www.runoob.com/wp-content/uploads/2020/06/ArrayList-1-768x406-1.png)
它可以动态修改数组，没有固定大小，可以删除和添加元素。
**特点**：查询快，增删慢
**底层原理**：底层采用数组存储元素，默认构造器初始化 size 是0，第一次 add size 扩容为 10。oldCapacity >> 1，相当于*1/2，也就是扩容为原来的1.5倍。

详细api方法可以查看：[官方API文档](https://docs.oracle.com/javase/8/docs/api/index.html)

##### LinkedList
链表（Linked list）是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的地址。
链表可以分为单链表和双链表。

**特点**：查询慢，增删相对快；但是对于首尾元素的增删改查极快（双链表，不需要遍历整个链表），因此可以用来设计队列和栈。
**底层原理**：底层采用双链表存储元素，



#### Set

##### 认识哈希值
就是一个int类型的随机值，Java每个对象都有一个哈希值。
Object中定义了HashCode()，每个对象都可以调用。
特点：
- 同一个对象多次调用 HashCode() 返回值是一样的
- 不同的对象调用 HashCode() 返回值一般是不相等的，相等的情况被叫做哈希碰撞
##### HashSet

1. **哈希表**
- JDK8之前，哈希表= 数组+链表
- JDK8开始，哈希表= 数组+链表+红黑树
- 哈希表是一种增删改查，性能都比较好的数据结构

2. **底层原理**
HashSet 底层基于哈希表存储数据的。
- ① 创建一个默认长度为16的数字，默认加载因子为0.75（元素个数=oldcapacity * 0.75 时，扩容），数组名为table
- ② 使用元素的哈希值对数组的长度做运算，计算出应存入的位置
- ③ 判断当前位置是否为null，如果是null，就直接存入
- ④ 如果不为null，调用equals比较，相等，则不存；不相等，则存入数组。
    + JDK8之前，新元素存入数组，老元素挂在下面，就是链表。
    + JDK8开始，新元素直接挂在老元素下面；当链表长度>8，且数组长度>=64时，自动将链表转为红黑树。

3. **自定义去重**
加入两个属性一样的student对象，因为对象地址不一样，不会去重。要去除这种形式的重复对象，就只能自定义
这时候，就需要重写 HashCode() 和 equals()。这里不明白的话，就在看看**底层原理**
重写时在 Student 类里面重写，idea可以快捷生成。

##### LinkedHashSet
也是基于哈希表（数组、链表、红黑树）实现的，通过双链表来维护先后顺序。

##### TreeSet
底层基于红黑树
> 数值类型默认按大小升序排列
> String 类型按首字符编号升序排列   
**对象类型：如 Student，是无法直接排序的。**
如果非要排序，也可以；有两种方法
1. 对象类实现comparable接口，重写compareTo方法，指定大小比较规则。
```java
// o1.compareTo(o2)
// o1 是比较者，o2 是被比较者
// 升序规定：如果左边大于右边，请放回正整数；反之，请返回负整数；相等返回0
@Override
public int compareTo(Student o){
    if(this.age > o.getAge()) return 1;//类里面可以直接用 this 调用 
    if(this.age < o.getAge()) return -1;
    return 0;//TreeSet中，相等只会保留一个；如果一定要保留，这不要 0 的情况，重新自定义
}
```
2. 使用集合自带比较器 Comparator，指定比较规则：`public TreeSet(Comparator c)`
```java
Set<Student> stu = new TreeSet(new Comparator<Student>(){
    @Override
    public int compare(Student o1,Student o2){
        return o1.getAge()-o2.getAge();//如果是小数的话，尽量调用 Double.Compare(o1.getxx-o2.getxxx)
    }
});
```




#### Map
存储 Key-Value 键值对数据，格式为{key1=val1,key2=val2,……}，Key 不允许重复（重复则覆盖），Value 可以重复。允许至多一个 null 键 和多个 null 值。
##### HashMap
![HashMap](https://www.runoob.com/wp-content/uploads/2020/07/WV9wXLl.png)
常用方法：
```java
HashMap<String,Integer> map = new HashMap();
// put get size clear isEmpty
Set<String> keys = map.keySet();//Set 集合的特点与key的特点一致，因此用Set集合接收。
Collection<Integer> values =map.values();
```

HashMap 底层和HashSet 一样，HashSet 底层调用的 HashMap

##### LinkedHashMap
LinkedHashMap是LinkedHashset的底层原理，底层直接 new LinkedHashMap

##### TreeMap
从 Java 7 开始，TreeMap 不允许使用 null 作为键
底层就是TreeSet的底层，TreeSet 底层就是 new TreeMap

### NIO Files 
用于简化文件I/O操作

### 泛型
定义：定义类、接口、方法时，同时声明一个或者多个类型的变量
格式：`public <T> void printArray(T[] arr){...}` 或者 `public class ArrayList<T>{....}`，在 "<>" 中声明类型。
作用：在编译阶段约束所能操作的数据类型，避免强制转换出错。

> 像 `public <T> void printArray(T[] arr){...}` 定义时拥有返回值，void 就改为 T。
**泛型类型参数约定：**

| 类型参数 | 含义 | 常用场景 |
|---------|------|---------|
| `E` | Element (元素) | 在集合中使用，因为集合中存放的是元素 |
| `T` | Type (类型) | 表示一个Java类 |
| `K` | Key (键) | 在映射中表示键的类型 |
| `V` | Value (值) | 在映射中表示值的类型 |
| `N` | Number (数值类型) | 表示数值类型 |
| `?` | 通配符 | **使用泛型时**（不是定义），表示所有的Java类型 |
| `R` | Result (结果) | 表示方法返回值的类型 |
| `U`, `S` | 其他类型 | 当需要多个类型参数时使用 |

**上下限：**
- 泛型上限：? extends Car，? 必须接收 Car 或者其子类
- 泛型下限：? super Car，? 必须接收Car 或者其父类

**支持的类型：**
不支持基本数据类型，只支持对象类型（引用类型）

### 序列化
是将对象转为字节流，反序列化是将字节流重新转为对象。
要实现序列化，只需要类实现 Serializable 接口即可。
### 网络编程
主要是 socket 编程。

### 发送邮件
遇到再补充


### 多线程编程
通过实现 Runnable 接口；
通过继承 Thread 类本身；
通过 Callable 和 Future 创建线程

### Applet
嵌入 HTML 的小程序，已经过时，不必理会。
### 文档注释
后续将常用的idea文档注释添加到这里

### Java 8新特性
#### Lambda
可以替代某些**函数式接口**的内部类的对象，让代码更加简洁。
而函数式接口就是：有且只有一个抽象方法的接口。
> @FunctionalInterface 是专门给函数式接口中的注解，声明后只能有一个抽象方法。
格式：`(args)->{}`

实例：可以简化集合里面的comparator的写法,如将上文的 comparator 简写为下面：
```java
//初步省略
Arrays.sort(arr,(Integer o1, Integer o2) -> {return o1-o2});
//参数类型也可以不写
Arrays.sort(arr,(o1, o2) -> {return o1-o2});
//方法体只有一行代码时，大括号可以不写，“;”省略，如果式return语句，return也不写。
Arrays.sort(arr,(o1, o2) ->  o1-o2);
//只有一个参数时候，小括号也可以省略
btn.btn.addActionListener(e->{});
```
##### 方法引用
1. 静态方法引用
使用场景：lambda 表达式只调用了一个静态方法，并且“->”前后方法参数形式一致。
格式：类名::静态方法

示例1：
```java
Arrays.sort(arr,(o1, o2) ->  orderArr(o1,o2));
//像这样的情况，orderArr 是静态方法，可以进一步简写。其中 integer 可以换成 student 中的 age 去理解
Arrays.sort(arr,Integer::orderArr)
```

示例2：
```java
arr.forEach(e -> System.out.println(1))
arr.forEach(System.out::println(1))
```



2. 实例方法引用
使用场景：lambda 表达式只通过对象名调用实例方法，并且“->”前后方法参数形式一致。
格式：对象名::实例方法
```java
Arrays.sort(arr,(o1, o2) ->  obj.orderArr(o1,o2));
//简写为
Arrays.sort(arr,obj::orderArr);
```
3. 特定类的方法引用
使用场景：lambda 表达式只调用了一个特定类型的实例方法，并且前面参数列表中的第一个参数作为方法的主调，其他所有参数都是被调用方法的参数。
格式：特定类的名称::方法
```java
String[] arr = {"angel","bro","andy"};
//忽略英文大小写排序
Arrays.sort(arr,(o1, o2) ->  {
    return o1.compareToIngnoreCase(o2);
});
//使用特定类的方法引用，可以简写为
Arrays.sort(arr,String::compareToIngnoreCase)
```

4. 构造器引用
使用场景：lambda 表达式里面只创建对象，并且“->”前后方法参数形式一致。
格式：类名::new
示例1：
```java
@FunctionalInterface
interface CarFactory{
    Car getCar(String name);
}
// lambda 表达式改写内部类如下
CarFactory cf = name -> new Car(name);
//使用构造器引用，改写为
CarFactory cf = Car::new;

Car ca = cf.getCar("xxx");
```

示例2：
```java
//JDK11 才有
ArrayList<String> list = xxx;
String[] arr = list.toArray(String::new);
```

#### Stream
用于操作集合或者数组的数据，性能高效，结合了大量lambda表达式，代码简洁，可读性好。

1. 获取Stream流
- 集合中 Collection 中封装了 `default Stream<E> stream()`，可以直接调用。
    + 单列集合调用这个Collectin中stream获取流
    + 双列集合用`map.keySet().stream();map.values().stream();map.entrySet().stream()`获取stream流
- 数组中：
    + Arrays类提供了`public static<T> stream<T> stream(T[] array)`；
    + Stream类提供了`public static<T> Stream<T> of(T... values)`

2. Stream流常用中间方法
| 方法名                                                                 | 说明                               |
| :--------------------------------------------------------------------- | :--------------------------------- |
| `Stream<T> filter(Predicate<? super T> predicate)`                     | 用于对流中的数据进行过滤。           |
| `Stream<T> sorted()`                                                   | 对元素进行升序排序。                 |
| `Stream<T> sorted(Comparator<? super T> comparator)`                   | 按照指定规则排序。                   |
| `Stream<T> limit(long maxSize)`                                        | 获取前几个元素。                     |
| `Stream<T> skip(long n)`                                               | 跳过前几个元素。                     |
| `Stream<T> distinct()`                                                 | 去除流中重复的元素。                 |
| `<R> Stream<R> map(Function<? super T, ? extends R> mapper)`           | 对元素进行加工，并返回对应的新流。     |
| `static <T> Stream<T> concat(Stream a, Stream b)`                      | 合并a和b两个流为一个流。             |

3. Stream常用终结方法
终结方法：获取处理的结果的方法。
| 方法名 | 说明 |
| :--- | :--- |
| `void forEach(Consumer<? super T> action)` | 对此流运算后的元素执行遍历 |
| `long count()` | 统计此流运算后的元素个数 |
| `Optional<T> max(Comparator<? super T> comparator)` | 获取此流运算后的最大值元素 |
| `Optional<T> min(Comparator<? super T> comparator)` | 获取此流运算后的最小值元素 |
| `Object[] toArray()` | 把流处理后的结果收集到一个数组中去 |
| `R collect(Collector collector)` | 把流处理后的结果收集到一个指定的集合中去 |
| **Collectors工具类方法** | **说明** |
| `public static <T> Collector toList()` | 把元素收集到List集合中 |
| `public static <T> Collector toSet()` | 把元素收集到Set集合中 |
| `public static Collector toMap(Function keyMapper, Function valueMapper)` | 把元素收集到Map集合中 |


### MySql 连接
1. [下载驱动 jar](https://static.jyshare.com/download/mysql-connector-java-8.0.16.jar)
2. 示例代码如下：
```java
package com.runoob.test;
 
import java.sql.*;
 
public class MySQLDemo {
 
    // MySQL 8.0 以下版本 - JDBC 驱动名及数据库 URL
    static final String JDBC_DRIVER = "com.mysql.jdbc.Driver";  
    static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB";
 
    // MySQL 8.0 以上版本 - JDBC 驱动名及数据库 URL
    //static final String JDBC_DRIVER = "com.mysql.cj.jdbc.Driver";  
    //static final String DB_URL = "jdbc:mysql://localhost:3306/RUNOOB?useSSL=false&allowPublicKeyRetrieval=true&serverTimezone=UTC";
 
 
    // 数据库的用户名与密码，需要根据自己的设置
    static final String USER = "root";
    static final String PASS = "123456";
 
    public static void main(String[] args) {
        Connection conn = null;
        Statement stmt = null;
        try{
            // 注册 JDBC 驱动
            Class.forName(JDBC_DRIVER);
        
            // 打开链接
            System.out.println("连接数据库...");
            conn = DriverManager.getConnection(DB_URL,USER,PASS);
        
            // 执行查询
            System.out.println(" 实例化Statement对象...");
            stmt = conn.createStatement();
            String sql;
            sql = "SELECT id, name, url FROM websites";
            ResultSet rs = stmt.executeQuery(sql);
        
            // 展开结果集数据库
            while(rs.next()){
                // 通过字段检索
                int id  = rs.getInt("id");
                String name = rs.getString("name");
                String url = rs.getString("url");
    
                // 输出数据
                System.out.print("ID: " + id);
                System.out.print(", 站点名称: " + name);
                System.out.print(", 站点 URL: " + url);
                System.out.print("\n");
            }
            // 完成后关闭
            rs.close();
            stmt.close();
            conn.close();
        }catch(SQLException se){
            // 处理 JDBC 错误
            se.printStackTrace();
        }catch(Exception e){
            // 处理 Class.forName 错误
            e.printStackTrace();
        }finally{
            // 关闭资源
            try{
                if(stmt!=null) stmt.close();
            }catch(SQLException se2){
            }// 什么都不做
            try{
                if(conn!=null) conn.close();
            }catch(SQLException se){
                se.printStackTrace();
            }
        }
        System.out.println("Goodbye!");
    }
}
```

