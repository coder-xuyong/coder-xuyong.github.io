---
title: java 面向对象
categories:
  - 1.Java
  - 1.JavaSE
  - 1.基础特性
tags:
  - Java
series:
  - 基础特性
order: 2
abbrlink: 48b2453f
date: 2025-08-30 14:38:56
---

# 面向对象
> 五大基本原则:单一职责原则(Single-Responsibility Principle)、开放封闭原则(Open-Closedprinciple)、Liskov替换原则(Liskov-Substituion Principle)、依较倒置原则(Dependency-lnversionPrinciple)和接口隔离原则(Interface-Segregation Principle)。

单一职责原则: 一个类最好只做一件事
开放封闭原则: 对扩展开放、对修改封闭
里氏替换原则: 子类必须能够替换其基类
依赖倒置原则: 程序要依赖于抽象接口，而不是具体的实现
接口隔离原则: 使用多个小的专门的接口，而不要使用一个大的总接口

## Java继承

### 继承的概念
继承就是子类继承父类的特征和行为，使得子类对象（实例）具有父类的实例域和方法，或子类从父类继承方法，使得子类具有父类相同的行为。

### 继承的特性
- 子类拥有父类非 private 的属性、方法
- 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
- 子类可以用自己的方式实现父类的方法。
- Java 的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如 B 类继承 A 类，C 类继承 B 类，所以按照关系就是 B 类是 C 类的父类，A 类是 B 类的父类，这是 Java 继承区别于 C++ 继承的一个特性。
- 提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系越紧密，代码独立性越差）

### 继承关键字
继承可以使用 extends 关键字来实现继承，而且所有的类都是继承于 java.lang.Object，当一个类没有继承的两个关键字，则默认继承 Object（这个类在 java.lang 包中，所以不需要 import）祖先类

- extends 关键字：在 Java 中，类的继承是单一继承，也就是说，一个子类只能拥有一个父类，所以 extends 只能继承一个类。
- implements 关键字：使用 implements 关键字可以变相的使java具有多继承的特性，使用范围为类实现接口的情况，可以同时实现多个接口
- super 关键字：我们可以通过 super 关键字来实现对父类成员的访问，用来引用当前对象的父类。
- this 关键字：指向自己的引用，引用当前对象，即它所在的方法或构造函数所属的对象实例。
- final 关键字：final 可以用来修饰变量（包括类属性、对象属性、局部变量和形参）、方法（包括类方法和对象方法）和类；使用 final 关键字声明类，就是把类定义定义为最终类，不能被继承，或者用于修饰方法，该方法不能被子类重写。

### 构造器
子类是不继承父类的构造器（构造方法或者构造函数）的，它只是调用（隐式或显式）。如果父类的构造器带有参数，则必须在子类的构造器中显式地通过 super 关键字调用父类的构造器并配以适当的参数列表。

如果父类构造器没有参数，则在子类的构造器中不需要使用 super 关键字调用父类构造器，系统会自动调用父类的无参构造器。

## Java 重写(Override)与重载(Overload)
### 重写(Override)
指子类定义了一个与其父类中具有相同名称、参数列表和返回类型的方法，并且子类方法的实现覆盖了父类方法的实现。 即外壳不变，核心重写！

#### 方法重写的规则
- 参数列表与被重写方法的参数列表必须完全相同。
- 返回类型与被重写方法的返回类型可以不相同，但是必须是父类返回值的派生类（java5 及更早版本返回类型要一样，java7 及更高版本可以不同）。
- 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为 public，那么在子类中重写该方法就不能声明为 protected。
- 父类的成员方法只能被它的子类重写。
- 声明为 final 的方法不能被重写。
- 声明为 static 的方法不能被重写，但是能够被再次声明。
- 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为 private 和 final 的方法。
- 子类和父类不在同一个包中，那么子类只能够重写父类的声明为 public 和 protected 的非 final 方法。
- 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
- 构造方法不能被重写。
- 如果不能继承一个类，则不能重写该类的方法。

#### super 关键字的使用
当需要在子类中调用父类的被重写方法时，要使用 super 关键字。

### 重载(Overload)
重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。

每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

#### 重载规则

- 被重载的方法必须改变参数列表(参数个数或类型不一样)；
- 被重载的方法可以改变返回类型；
- 被重载的方法可以改变访问修饰符；
- 被重载的方法可以声明新的或更广的检查异常；
- 方法能够在同一个类中或者在一个子类中被重载。
- 无法以返回值类型作为重载函数的区分标准。

### 重写与重载之间的区别
| 区别点     | 重载方法                                     | 重写方法                                             |
| :--------- | :------------------------------------------- | :--------------------------------------------------- |
| 参数列表   | 必须修改                                     | 一定不能修改                                         |
| 返回类型   | 可以修改                                     | 一定不能修改                                         |
| 异常       | 可以修改                                     | 可以减少或删除，一定不能抛出新的或者更广的异常         |
| 访问       | 可以修改                                     | 一定不能做更严格的限制（可以降低限制）               |

### 总结
方法的重写(Overriding)和重载(Overloading)是java多态性的不同表现，重写是父类与子类之间多态性的一种表现，重载可以理解成一个类的多态的具体表现形式。


## Java 多态
多态是同一个行为具有多个不同表现形式或形态的能力。
### 多态的优点
1. 消除类型之间的耦合关系
2. 可替换性
3. 可扩充性
4. 接口性
5. 灵活性
6. 简化性
### 多态存在的三个必要条件
- 继承
- 重写
- 父类引用指向子类对象：Parent p = new Child();

### 多态中的重写
当子类对象调用重写的方法时，调用的是子类的方法，而不是父类中被重写的方法。

要想调用父类中被重写的方法，则必须使用关键字 super。

### 多态的实现方式
- 重写
- 接口
- 抽象类和抽象方法

## 抽象类
抽象类不能被实例化对象（必须被继承才能被使用），其他和普通类一样。通常在设计阶段决定要不要设计抽象类。
关键字是 abstract 生命抽象类，使用 extends 继承抽象父类。

### 抽象方法
如果你想设计这样一个类，该类包含一个特别的成员方法，该方法的具体实现由它的子类确定，那么你可以在父类中声明该方法为抽象方法。
Abstract 关键字同样可以用来声明抽象方法，抽象方法只包含一个方法名，而没有方法体。

抽象方法没有定义，方法名后面直接跟一个分号，而不是花括号。

**声明抽象方法会造成以下两个结果：**

- 如果一个类包含抽象方法，那么该类必须是抽象类。
- 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。

### 抽象类总结规定
1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。

2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。

3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。

4. 构造方法，类方法（用 static 修饰的方法）不能声明为抽象方法。

5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

## Java 封装
只暴露自己想暴露的。

**优点：**
1. 良好的封装能够减少耦合。

2. 类内部的结构可以自由修改。

3. 可以对成员变量进行更精确的控制。

4. 隐藏信息，实现细节。

### 实现封装的步骤
1. 修改属性限制，如：private
2. 对外提供 get 和 set 方法去修改变量。


## Java 接口
接口是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
### 接口与类的区别
- 接口不能用于实例化对象。
- 接口没有构造方法。
- 接口中所有的方法必须是抽象方法，Java 8 之后 接口中可以使用 default 关键字修饰的非抽象方法。
- 接口不能包含成员变量，除了 static 和 final 变量。
- 接口不是被类继承了，而是要被类实现。
- 接口支持多继承。

### 接口的特性
- 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）
- 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误）。
- 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
### 抽象类和接口的区别
1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。



> 注：JDK 1.8 以后，接口里可以有静态方法和方法体了。
> 注：JDK 1.8 以后，接口允许包含具体实现的方法，该方法称为"默认方法"，默认方法使用 default 关键字修饰。更多内容可参考 Java 8 默认方法。
> 注：JDK 1.9 以后，允许将方法定义为 private，使得某些复用的代码不会把方法暴露出去。更多内容可参考 Java 9 私有接口方法。

## 枚举（enum）
```java
enum Color 
{ 
    RED, GREEN, BLUE; 
} 
```

## 反射
Java 反射（Reflection）是一个强大的特性，它允许程序在运行时查询、访问和修改类、接口、字段和方法的信息。反射提供了一种动态地操作类的能力，这在很多框架和库中被广泛使用，例如Spring框架的依赖注入。
它可以破坏封装性，可以绕过泛型的约束，可以得到一个类的全部成分进行操作。

### 反射 API
Java 的反射 API 提供了一系列的类和接口来操作 Class 对象。主要的类包括：

- java.lang.Class：表示类的对象。提供了方法来获取类的字段、方法、构造函数等。
- java.lang.reflect.Field：表示类的字段（属性）。提供了访问和修改字段的能力。
- java.lang.reflect.Method：表示类的方法。提供了调用方法的能力。
- java.lang.reflect.Constructor：表示类的构造函数。提供了创建对象的能力。
### 工作流程
- 获取 Class 对象：首先获取目标类的 Class 对象。
- 获取成员信息：通过 Class 对象，可以获取类的字段、方法、构造函数等信息。
- 操作成员：通过反射 API 可以读取和修改字段的值、调用方法以及创建对象。

### 常见应用
1. 获取 class 对象
```java
//通过类字面量:
Class<?> clazz = String.class;

//通过对象实例：
String str = "Hello";
Class<?> clazz = str.getClass();

//通过 Class.forName() 方法：
Class<?> clazz = Class.forName("java.lang.String");
```
2. 创建对象
```java
Class<?> clazz = Class.forName("java.lang.String");
Object obj = clazz.getDeclaredConstructor().newInstance();
```
3. 访问字段
```java
Class<?> clazz = Person.class;
Field field = clazz.getDeclaredField("name");
field.setAccessible(true); // 如果字段是私有的，需要设置为可访问
Object value = field.get(personInstance); // 获取字段值
field.set(personInstance, "New Name"); // 设置字段值
```
4. 调用方法
```java
Class<?> clazz = Person.class;
Method method = clazz.getMethod("sayHello");
method.invoke(personInstance);

Method methodWithArgs = clazz.getMethod("greet", String.class);
methodWithArgs.invoke(personInstance, "World");
```
5. 获取构造函数
```java
Class<?> clazz = Person.class;
Constructor<?> constructor = clazz.getConstructor(String.class, int.class);
Object obj = constructor.newInstance("John", 30);
```
6. 获取接口和父类
```java
Class<?> clazz = Person.class;

// 获取所有接口
Class<?>[] interfaces = clazz.getInterfaces();
for (Class<?> i : interfaces) {
    System.out.println("Interface: " + i.getName());
}

// 获取父类
Class<?> superClass = clazz.getSuperclass();
System.out.println("Superclass: " + superClass.getName());
```

> java.lang.reflect 相关方法可以查看[菜鸟教程](https://www.runoob.com/java/java-reflection.html)



# 参考
- https://www.runoob.com/java
- https://www.bilibili.com/video/BV1gb42177hm