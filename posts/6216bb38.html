<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java锁 | coder-xuyong</title><meta name="author" content="coder-xuyong"><meta name="copyright" content="coder-xuyong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="深入理解 Java 并发锁 本文先阐述 Java 中各种锁的概念。 然后，介绍锁的核心实现 AQS。 然后，重点介绍 Lock 和 Condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。 互斥，即同一时刻只允许一个线程访问共享资源； 同步，即线程之间如何通信、协作。 这两大问题，管程（sychronized）都是能够解决的。J.U.C 包还提供了 Lock 和 Conditio">
<meta property="og:type" content="article">
<meta property="og:title" content="Java锁">
<meta property="og:url" content="https://coder-xuyong.github.io/posts/6216bb38">
<meta property="og:site_name" content="coder-xuyong">
<meta property="og:description" content="深入理解 Java 并发锁 本文先阐述 Java 中各种锁的概念。 然后，介绍锁的核心实现 AQS。 然后，重点介绍 Lock 和 Condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。 互斥，即同一时刻只允许一个线程访问共享资源； 同步，即线程之间如何通信、协作。 这两大问题，管程（sychronized）都是能够解决的。J.U.C 包还提供了 Lock 和 Conditio">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp">
<meta property="article:published_time" content="2025-10-17T04:13:01.000Z">
<meta property="article:modified_time" content="2025-10-25T09:52:26.933Z">
<meta property="article:author" content="coder-xuyong">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java锁",
  "url": "https://coder-xuyong.github.io/posts/6216bb38",
  "image": "https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp",
  "datePublished": "2025-10-17T04:13:01.000Z",
  "dateModified": "2025-10-25T09:52:26.933Z",
  "author": [
    {
      "@type": "Person",
      "name": "coder-xuyong",
      "url": "https://coder-xuyong.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/img/logo.png"><link rel="canonical" href="https://coder-xuyong.github.io/posts/6216bb38"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: coder-xuyong","link":"链接: ","source":"来源: coder-xuyong","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java锁',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/self/custom.css"><link rel="stylesheet" href="/self/progress_bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/self/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-color: #fafafa;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/medias/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">97</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-bars-progress"></i><span> 合集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/medias/img/logo.png" alt="Logo"><span class="site-name">coder-xuyong</span></a><a class="nav-page-title" href="/"><span class="site-name">Java锁</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-bars-progress"></i><span> 合集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java锁<a class="post-edit-link" href="https://github.com/coder-xuyong/coder-xuyong.github.io/edit/main/source/_posts/01.Java/01.JavaSE/04.并发/03.Java锁.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-10-17T04:13:01.000Z" title="发表于 2025-10-17 12:13:01">2025-10-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-25T09:52:26.933Z" title="更新于 2025-10-25 17:52:26">2025-10-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/">1.Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/1-JavaSE/">1.JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/1-JavaSE/4-%E5%B9%B6%E5%8F%91/">4.并发</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">13.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>55分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;天自上次更新，文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-10-25 17:52:26&quot;}" hidden></div><h1 id="深入理解-Java-并发锁"><a href="#深入理解-Java-并发锁" class="headerlink" title="深入理解 Java 并发锁"></a>深入理解 Java 并发锁</h1><blockquote>
<p>本文先阐述 Java 中各种锁的概念。</p>
<p>然后，介绍锁的核心实现 AQS。</p>
<p>然后，重点介绍 Lock 和 Condition 两个接口及其实现。并发编程有两个核心问题：同步和互斥。</p>
<p><strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；</p>
<p><strong>同步</strong>，即线程之间如何通信、协作。</p>
<p>这两大问题，管程（<code>sychronized</code>）都是能够解决的。<strong>J.U.C 包还提供了 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。</p>
</blockquote>
<h2 id="并发锁简介"><a href="#并发锁简介" class="headerlink" title="并发锁简介"></a>并发锁简介</h2><p>确保线程安全最常见的做法是利用锁机制（<code>Lock</code>、<code>sychronized</code>）来对共享数据做互斥同步，这样在同一个时刻，只有一个线程可以执行某个方法或者某个代码块，那么操作必然是原子性的，线程安全的。</p>
<h3 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h3><p><strong>可重入锁，顾名思义，指的是线程可以重复获取同一把锁</strong>。即同一个线程在外层方法获取了锁，在进入内层方法会自动获取锁。</p>
<blockquote>
<p>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p>
</blockquote>
<p><strong>可重入锁可以在一定程度上避免死锁</strong>。</p>
<ul>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code> 是可重入锁</strong>。这点，从其命名也不难看出。</li>
<li><strong><code>synchronized</code> 也是一个可重入锁</strong>。</li>
</ul>
<p>【示例】<code>synchronized</code> 的可重入示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setA</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    setB();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">setB</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码就是一个典型场景：如果使用的锁不是可重入锁的话，<code>setB</code> 可能不会被当前线程执行，从而造成死锁。</p>
<p>【示例】<code>ReentrantLock</code> 的可重入示例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> value;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Task</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.value = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> value;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 保证锁能释放</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addOne</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 获取锁</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 注意：此处已经成功获取锁，进入 get 方法后，又尝试获取锁，</span></span><br><span class="line">            <span class="comment">// 如果锁不是可重入的，会导致死锁</span></span><br><span class="line">            value = <span class="number">1</span> + get();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 保证锁能释放</span></span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h3 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h3><ul>
<li><strong>公平锁</strong> - 公平锁是指 <strong>多线程按照申请锁的顺序来获取锁</strong>。</li>
<li><strong>非公平锁</strong> - 非公平锁是指 <strong>多线程不按照申请锁的顺序来获取锁</strong> 。这就可能会出现优先级反转（后来者居上）或者饥饿现象（某线程总是抢不过别的线程，导致始终无法执行）。</li>
</ul>
<p>公平锁为了保证线程申请顺序，势必要付出一定的性能代价，因此其吞吐量一般低于非公平锁。</p>
<p>公平锁与非公平锁 在 Java 中的典型实现：</p>
<ul>
<li><strong><code>synchronized</code> 只支持非公平锁</strong>。</li>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁</strong>。</li>
</ul>
<h3 id="独享锁与共享锁"><a href="#独享锁与共享锁" class="headerlink" title="独享锁与共享锁"></a>独享锁与共享锁</h3><p>独享锁与共享锁是一种广义上的说法，从实际用途上来看，也常被称为互斥锁与读写锁。</p>
<ul>
<li><strong>独享锁</strong> - 独享锁是指 <strong>锁一次只能被一个线程所持有</strong>。</li>
<li><strong>共享锁</strong> - 共享锁是指 <strong>锁可被多个线程所持有</strong>。</li>
</ul>
<p>独享锁与共享锁在 Java 中的典型实现：</p>
<ul>
<li><strong><code>synchronized</code> 、<code>ReentrantLock</code> 只支持独享锁</strong>。</li>
<li><strong><code>ReentrantReadWriteLock</code> 其写锁是独享锁，其读锁是共享锁</strong>。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
</ul>
<h3 id="悲观锁与乐观锁"><a href="#悲观锁与乐观锁" class="headerlink" title="悲观锁与乐观锁"></a>悲观锁与乐观锁</h3><p>乐观锁与悲观锁不是指具体的什么类型的锁，而是<strong>处理并发同步的策略</strong>。</p>
<ul>
<li><strong>悲观锁</strong> - 悲观锁对于并发采取悲观的态度，认为：<strong>不加锁的并发操作一定会出问题</strong>。<strong>悲观锁适合写操作频繁的场景</strong>。</li>
<li><strong>乐观锁</strong> - 乐观锁对于并发采取乐观的态度，认为：<strong>不加锁的并发操作也没什么问题。对于同一个数据的并发操作，是不会发生修改的</strong>。在更新数据的时候，会采用不断尝试更新的方式更新数据。<strong>乐观锁适合读多写少的场景</strong>。</li>
</ul>
<p>悲观锁与乐观锁在 Java 中的典型实现：</p>
<ul>
<li><p>悲观锁在 Java 中的应用就是通过使用 <code>synchronized</code> 和 <code>Lock</code> 显示加锁来进行互斥同步，这是一种阻塞同步。</p>
</li>
<li><p>乐观锁在 Java 中的应用就是采用 <code>CAS</code> 机制（<code>CAS</code> 操作通过 <code>Unsafe</code> 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。</p>
</li>
</ul>
<h3 id="偏向锁、轻量级锁、重量级锁"><a href="#偏向锁、轻量级锁、重量级锁" class="headerlink" title="偏向锁、轻量级锁、重量级锁"></a>偏向锁、轻量级锁、重量级锁</h3><p>所谓轻量级锁与重量级锁，指的是锁控制粒度的粗细。显然，控制粒度越细，阻塞开销越小，并发性也就越高。</p>
<p>Java 1.6 以前，重量级锁一般指的是 <code>synchronized</code> ，而轻量级锁指的是 <code>volatile</code>。</p>
<p>Java 1.6 以后，针对 <code>synchronized</code> 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。</p>
<ul>
<li><p><strong>偏向锁</strong> - 偏向锁是指一段同步代码一直被一个线程所访问，那么该线程会自动获取锁。降低获取锁的代价。</p>
</li>
<li><p><strong>轻量级锁</strong> - 是指当锁是偏向锁的时候，被另一个线程所访问，偏向锁就会升级为轻量级锁，其他线程会通过自旋的形式尝试获取锁，不会阻塞，提高性能。</p>
</li>
<li><p><strong>重量级锁</strong> - 是指当锁为轻量级锁的时候，另一个线程虽然是自旋，但自旋不会一直持续下去，当自旋一定次数的时候，还没有获取到锁，就会进入阻塞，该锁膨胀为重量级锁。重量级锁会让其他申请的线程进入阻塞，性能降低。</p>
</li>
</ul>
<h3 id="分段锁"><a href="#分段锁" class="headerlink" title="分段锁"></a>分段锁</h3><p>分段锁其实是一种锁的设计，并不是具体的一种锁。所谓分段锁，就是把锁的对象分成多段，每段独立控制，使得锁粒度更细，减少阻塞开销，从而提高并发性。这其实很好理解，就像高速公路上的收费站，如果只有一个收费口，那所有的车只能排成一条队缴费；如果有多个收费口，就可以分流了。</p>
<p><code>Hashtable</code> 使用 <code>synchronized</code> 修饰方法来保证线程安全性，那么面对线程的访问，Hashtable 就会锁住整个对象，所有的其它线程只能等待，这种阻塞方式的吞吐量显然很低。</p>
<p>Java 1.7 以前的 <code>ConcurrentHashMap</code> 就是分段锁的典型案例。<code>ConcurrentHashMap</code> 维护了一个 <code>Segment</code> 数组，一般称为分段桶。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Segment&lt;K,V&gt;[] segments;</span><br></pre></td></tr></table></figure>

<p>当有线程访问 <code>ConcurrentHashMap</code> 的数据时，<code>ConcurrentHashMap</code> 会先根据 hashCode 计算出数据在哪个桶（即哪个 Segment），然后锁住这个 <code>Segment</code>。</p>
<h3 id="显示锁和内置锁"><a href="#显示锁和内置锁" class="headerlink" title="显示锁和内置锁"></a>显示锁和内置锁</h3><p>Java 1.5 之前，协调对共享对象的访问时可以使用的机制只有 <code>synchronized</code> 和 <code>volatile</code>。这两个都属于内置锁，即锁的申请和释放都是由 JVM 所控制。</p>
<p>Java 1.5 之后，增加了新的机制：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> ，这类锁的申请和释放都可以由程序所控制，所以常被称为显示锁。</p>
<p>以下对比一下显示锁和内置锁的差异：</p>
<ul>
<li><strong>主动获取锁和释放锁</strong><ul>
<li><code>synchronized</code> 不能主动获取锁和释放锁。获取锁和释放锁都是 JVM 控制的。</li>
<li><code>ReentrantLock</code> 可以主动获取锁和释放锁。（如果忘记释放锁，就可能产生死锁）。</li>
</ul>
</li>
<li><strong>响应中断</strong><ul>
<li><code>synchronized</code> 不能响应中断。</li>
<li><code>ReentrantLock</code> 可以响应中断。</li>
</ul>
</li>
<li><strong>超时机制</strong><ul>
<li><code>synchronized</code> 没有超时机制。</li>
<li><code>ReentrantLock</code> 有超时机制。<code>ReentrantLock</code> 可以设置超时时间，超时后自动释放锁，避免一直等待。</li>
</ul>
</li>
<li><strong>支持公平锁</strong><ul>
<li><code>synchronized</code> 只支持非公平锁。</li>
<li><code>ReentrantLock</code> 支持非公平锁和公平锁。</li>
</ul>
</li>
<li><strong>是否支持共享</strong><ul>
<li>被 <code>synchronized</code> 修饰的方法或代码块，只能被一个线程访问（独享）。如果这个线程被阻塞，其他线程也只能等待</li>
<li><code>ReentrantLock</code> 可以基于 <code>Condition</code> 灵活的控制同步条件。</li>
</ul>
</li>
<li><strong>是否支持读写分离</strong><ul>
<li><code>synchronized</code> 不支持读写锁分离；</li>
<li><code>ReentrantReadWriteLock</code> 支持读写锁，从而使阻塞读写的操作分开，有效提高并发性。</li>
</ul>
</li>
</ul>
<h2 id="Lock-和-Condition"><a href="#Lock-和-Condition" class="headerlink" title="Lock 和 Condition"></a>Lock 和 Condition</h2><h3 id="为何引入-Lock-和-Condition"><a href="#为何引入-Lock-和-Condition" class="headerlink" title="为何引入 Lock 和 Condition"></a>为何引入 Lock 和 Condition</h3><p>并发编程领域，有两大核心问题：一个是<strong>互斥</strong>，即同一时刻只允许一个线程访问共享资源；另一个是<strong>同步</strong>，即线程之间如何通信、协作。这两大问题，管程都是能够解决的。<strong>Java SDK 并发包通过 Lock 和 Condition 两个接口来实现管程，其中 Lock 用于解决互斥问题，Condition 用于解决同步问题</strong>。</p>
<p>synchronized 是管程的一种实现，既然如此，何必再提供 Lock 和 Condition。</p>
<p>JDK 1.6 以前，synchronized 还没有做优化，性能远低于 Lock。但是，性能不是引入 Lock 的最重要因素。真正关键在于：synchronized 使用不当，可能会出现死锁。</p>
<p>synchronized 无法通过<strong>破坏不可抢占条件</strong>来避免死锁。原因是 synchronized 申请资源的时候，如果申请不到，线程直接进入阻塞状态了，而线程进入阻塞状态，啥都干不了，也释放不了线程已经占有的资源。</p>
<p>与内置锁 <code>synchronized</code> 不同的是，<strong><code>Lock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作</strong>，所有获取锁、释放锁的操作都是显式的操作。</p>
<ul>
<li><strong>能够响应中断</strong>。synchronized 的问题是，持有锁 A 后，如果尝试获取锁 B 失败，那么线程就进入阻塞状态，一旦发生死锁，就没有任何机会来唤醒阻塞的线程。但如果阻塞状态的线程能够响应中断信号，也就是说当我们给阻塞的线程发送中断信号的时候，能够唤醒它，那它就有机会释放曾经持有的锁 A。这样就破坏了不可抢占条件了。</li>
<li><strong>支持超时</strong>。如果线程在一段时间之内没有获取到锁，不是进入阻塞状态，而是返回一个错误，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
<li><strong>非阻塞地获取锁</strong>。如果尝试获取锁失败，并不进入阻塞状态，而是直接返回，那这个线程也有机会释放曾经持有的锁。这样也能破坏不可抢占条件。</li>
</ul>
<h3 id="Lock-接口"><a href="#Lock-接口" class="headerlink" title="Lock 接口"></a>Lock 接口</h3><p><code>Lock</code> 的接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Lock</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">lockInterruptibly</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">tryLock</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span>;</span><br><span class="line">    Condition <span class="title function_">newCondition</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>lock()</code> - 获取锁。</li>
<li><code>unlock()</code> - 释放锁。</li>
<li><code>tryLock()</code> - 尝试获取锁，仅在调用时锁未被另一个线程持有的情况下，才获取该锁。</li>
<li><code>tryLock(long time, TimeUnit unit)</code> - 和 <code>tryLock()</code> 类似，区别仅在于限定时间，如果限定时间内未获取到锁，视为失败。</li>
<li><code>lockInterruptibly()</code> - 锁未被另一个线程持有，且线程没有被中断的情况下，才能获取锁。</li>
<li><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。</li>
</ul>
<h3 id="Condition"><a href="#Condition" class="headerlink" title="Condition"></a>Condition</h3><p><strong>Condition 实现了管程模型里面的条件变量</strong>。</p>
<p>在单线程中，一段代码的执行可能依赖于某个状态，如果不满足状态条件，代码就不会被执行（典型的场景，如：<code>if ... else ...</code>）。在并发环境中，当一个线程判断某个状态条件时，其状态可能是由于其他线程的操作而改变，这时就需要有一定的协调机制来确保在同一时刻，数据只能被一个线程锁修改，且修改的数据状态被所有线程所感知。</p>
<p>Java 1.5 之前，主要是利用 <code>Object</code> 类中的 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 配合 <code>synchronized</code> 来进行线程间通信。</p>
<p><code>wait</code>、<code>notify</code>、<code>notifyAll</code> 需要配合 <code>synchronized</code> 使用，不适用于 <code>Lock</code>。而使用 <code>Lock</code> 的线程，彼此间通信应该使用 <code>Condition</code> 。这可以理解为，什么样的锁配什么样的钥匙。<strong>内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code> ）</strong>。</p>
<h4 id="Condition-的特性"><a href="#Condition-的特性" class="headerlink" title="Condition 的特性"></a>Condition 的特性</h4><p><code>Condition</code> 接口定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Condition</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">awaitUninterruptibly</span><span class="params">()</span>;</span><br><span class="line">    <span class="type">long</span> <span class="title function_">awaitNanos</span><span class="params">(<span class="type">long</span> nanosTimeout)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">await</span><span class="params">(<span class="type">long</span> time, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">awaitUntil</span><span class="params">(Date deadline)</span> <span class="keyword">throws</span> InterruptedException;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signal</span><span class="params">()</span>;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">signalAll</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中，<code>await</code>、<code>signal</code>、<code>signalAll</code> 与 <code>wait</code>、<code>notify</code>、<code>notifyAll</code> 相对应，功能也相似。除此以外，<code>Condition</code> 相比内置条件队列（ <code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），提供了更为丰富的功能：</p>
<ul>
<li>每个锁（<code>Lock</code>）上可以存在多个 <code>Condition</code>，这意味着锁的状态条件可以有多个。</li>
<li>支持公平的或非公平的队列操作。</li>
<li>支持可中断的条件等待，相关方法：<code>awaitUninterruptibly()</code> 。</li>
<li>支持可定时的等待，相关方法：<code>awaitNanos(long)</code> 、<code>await(long, TimeUnit)</code>、<code>awaitUntil(Date)</code>。</li>
</ul>
<h4 id="Condition-的用法"><a href="#Condition-的用法" class="headerlink" title="Condition 的用法"></a>Condition 的用法</h4><p>这里以 <code>Condition</code> 来实现一个消费者、生产者模式。</p>
<p>产品类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">producedMsg</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">consumedMsg</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> state;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> end;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">consume</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//lock</span></span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// no new message wait for new message</span></span><br><span class="line">            <span class="keyword">while</span> (!state) &#123; producedMsg.await(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;consume message : &quot;</span> + message);</span><br><span class="line">            state = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// message consumed, notify waiting thread</span></span><br><span class="line">            consumedMsg.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread interrupted - viewMessage&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">(String message)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// last message not consumed, wait for it be consumed</span></span><br><span class="line">            <span class="keyword">while</span> (state) &#123; consumedMsg.await(); &#125;</span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">&quot;produce msg: &quot;</span> + message);</span><br><span class="line">            <span class="built_in">this</span>.message = message;</span><br><span class="line">            state = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// new message added, notify waiting thread</span></span><br><span class="line">            producedMsg.signal();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Thread interrupted - publishMessage&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEnd</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEnd</span><span class="params">(<span class="type">boolean</span> end)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.end = end;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>消费者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageConsumer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageConsumer</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        message = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (!message.isEnd()) &#123; message.consume(); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>生产者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageProducer</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Message message;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MessageProducer</span><span class="params">(Message msg)</span> &#123;</span><br><span class="line">        message = msg;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        produce();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">produce</span><span class="params">()</span> &#123;</span><br><span class="line">        List&lt;String&gt; msgs = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        msgs.add(<span class="string">&quot;Begin&quot;</span>);</span><br><span class="line">        msgs.add(<span class="string">&quot;Msg1&quot;</span>);</span><br><span class="line">        msgs.add(<span class="string">&quot;Msg2&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String msg : msgs) &#123;</span><br><span class="line">            message.produce(msg);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        message.produce(<span class="string">&quot;End&quot;</span>);</span><br><span class="line">        message.setEnd(<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LockConditionDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Message</span> <span class="variable">msg</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Message</span>();</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">producer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MessageProducer</span>(msg));</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">consumer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MessageConsumer</span>(msg));</span><br><span class="line">        producer.start();</span><br><span class="line">        consumer.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><p><code>ReentrantLock</code> 类是 <code>Lock</code> 接口的具体实现，与内置锁 <code>synchronized</code> 相同的是，它是一个<strong>可重入锁</strong>。</p>
<h3 id="ReentrantLock-的特性"><a href="#ReentrantLock-的特性" class="headerlink" title="ReentrantLock 的特性"></a>ReentrantLock 的特性</h3><p><code>ReentrantLock</code> 的特性如下：</p>
<ul>
<li><strong><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性</strong>。</li>
<li><code>ReentrantLock</code> <strong>支持公平锁和非公平锁</strong>（默认）两种模式。</li>
<li><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的<strong>灵活性</strong>。<ul>
<li><code>synchronized</code> 无法中断一个正在等待获取锁的线程</li>
<li><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</li>
</ul>
</li>
</ul>
<h3 id="ReentrantLock-的用法"><a href="#ReentrantLock-的用法" class="headerlink" title="ReentrantLock 的用法"></a>ReentrantLock 的用法</h3><p>前文了解了 <code>ReentrantLock</code> 的特性，接下来，我们要讲述其具体用法。</p>
<h4 id="ReentrantLock-的构造方法"><a href="#ReentrantLock-的构造方法" class="headerlink" title="ReentrantLock 的构造方法"></a>ReentrantLock 的构造方法</h4><p><code>ReentrantLock</code> 有两个构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">()</span> &#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ReentrantLock</span><span class="params">(<span class="type">boolean</span> fair)</span> &#123;&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>ReentrantLock()</code> - 默认构造方法会初始化一个<strong>非公平锁（NonfairSync）</strong>；</li>
<li><code>ReentrantLock(boolean)</code> - <code>new ReentrantLock(true)</code> 会初始化一个<strong>公平锁（FairSync）</strong>。</li>
</ul>
<h4 id="lock-和-unlock-方法"><a href="#lock-和-unlock-方法" class="headerlink" title="lock 和 unlock 方法"></a>lock 和 unlock 方法</h4><ul>
<li><code>lock()</code> - <strong>无条件获取锁</strong>。如果当前线程无法获取锁，则当前线程进入休眠状态不可用，直至当前线程获取到锁。如果该锁没有被另一个线程持有，则获取该锁并立即返回，将锁的持有计数设置为 1。</li>
<li><code>unlock()</code> - 用于<strong>释放锁</strong>。</li>
</ul>
<blockquote>
<p>🔔 注意：请务必牢记，获取锁操作 <strong><code>lock()</code> 必须在 <code>try catch</code> 块中进行，并且将释放锁操作 <code>unlock()</code> 放在 <code>finally</code> 块中进行，以保证锁一定被被释放，防止死锁的发生</strong>。</p>
</blockquote>
<p>示例：<code>ReentrantLock</code> 的基本操作</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReentrantLockDemo</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Task</span> <span class="variable">task</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Task</span>();</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">tA</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;Thread-A&quot;</span>, task);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">tB</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;Thread-B&quot;</span>, task);</span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">tC</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;Thread-C&quot;</span>, task);</span><br><span class="line">        tA.start();</span><br><span class="line">        tB.start();</span><br><span class="line">        tC.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> Task task;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name, Task task)</span> &#123;</span><br><span class="line">            <span class="built_in">super</span>(name);</span><br><span class="line">            <span class="built_in">this</span>.task = task;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">            task.execute();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Task</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    System.out.println(lock.toString());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 查询当前线程 hold 住此锁的次数</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;\t holdCount: &quot;</span> + lock.getHoldCount());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 查询正等待获取此锁的线程数</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;\t queuedLength: &quot;</span> + lock.getQueueLength());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否为公平锁</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;\t isFair: &quot;</span> + lock.isFair());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否被锁住</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;\t isLocked: &quot;</span> + lock.isLocked());</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 是否被当前线程持有锁</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;\t isHeldByCurrentThread: &quot;</span> + lock.isHeldByCurrentThread());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-A]</span><br><span class="line">	 holdCount: <span class="number">1</span></span><br><span class="line">	 queuedLength: <span class="number">2</span></span><br><span class="line">	 isFair: <span class="literal">false</span></span><br><span class="line">	 isLocked: <span class="literal">true</span></span><br><span class="line">	 isHeldByCurrentThread: <span class="literal">true</span></span><br><span class="line">java.util.concurrent.locks.ReentrantLock@64fcd88a[Locked by thread Thread-C]</span><br><span class="line">	 holdCount: <span class="number">1</span></span><br><span class="line">	 queuedLength: <span class="number">1</span></span><br><span class="line">	 isFair: <span class="literal">false</span></span><br><span class="line">	 isLocked: <span class="literal">true</span></span><br><span class="line">	 isHeldByCurrentThread: <span class="literal">true</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure>

<h4 id="tryLock-方法"><a href="#tryLock-方法" class="headerlink" title="tryLock 方法"></a>tryLock 方法</h4><p>与无条件获取锁相比，tryLock 有更完善的容错机制。</p>
<ul>
<li><code>tryLock()</code> - <strong>可轮询获取锁</strong>。如果成功，则返回 true；如果失败，则返回 false。也就是说，这个方法<strong>无论成败都会立即返回</strong>，获取不到锁（锁已被其他线程获取）时不会一直等待。</li>
<li><code>tryLock(long, TimeUnit)</code> - <strong>可定时获取锁</strong>。和 <code>tryLock()</code> 类似，区别仅在于这个方法在<strong>获取不到锁时会等待一定的时间</strong>，在时间期限之内如果还获取不到锁，就返回 false。如果如果一开始拿到锁或者在等待期间内拿到了锁，则返回 true。</li>
</ul>
<p>示例：<code>ReentrantLock</code> 的 <code>tryLock()</code> 操作</p>
<p>修改上个示例中的 <code>execute()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lock.tryLock()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">               <span class="comment">// 略...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例：<code>ReentrantLock</code> 的 <code>tryLock(long, TimeUnit)</code> 操作</p>
<p>修改上个示例中的 <code>execute()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (lock.tryLock(<span class="number">2</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">                    <span class="comment">// 略...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁失败&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; 获取锁超时&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="lockInterruptibly-方法"><a href="#lockInterruptibly-方法" class="headerlink" title="lockInterruptibly 方法"></a>lockInterruptibly 方法</h4><ul>
<li><code>lockInterruptibly()</code> - <strong>可中断获取锁</strong>。可中断获取锁可以在获得锁的同时保持对中断的响应。可中断获取锁比其它获取锁的方式稍微复杂一些，需要两个 <code>try-catch</code> 块（如果在获取锁的操作中抛出了 <code>InterruptedException</code> ，那么可以使用标准的 <code>try-finally</code> 加锁模式）。<ul>
<li>举例来说：假设有两个线程同时通过 <code>lock.lockInterruptibly()</code> 获取某个锁时，若线程 A 获取到了锁，则线程 B 只能等待。若此时对线程 B 调用 <code>threadB.interrupt()</code> 方法能够中断线程 B 的等待过程。由于 <code>lockInterruptibly()</code> 的声明中抛出了异常，所以 <code>lock.lockInterruptibly()</code> 必须放在 <code>try</code> 块中或者在调用 <code>lockInterruptibly()</code> 的方法外声明抛出 <code>InterruptedException</code>。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注意：当一个线程获取了锁之后，是不会被 <code>interrupt()</code> 方法中断的。单独调用 <code>interrupt()</code> 方法不能中断正在运行状态中的线程，只能中断阻塞状态中的线程。因此当通过 <code>lockInterruptibly()</code> 方法获取某个锁时，如果未获取到锁，只有在等待的状态下，才可以响应中断。</p>
</blockquote>
<p>示例：<code>ReentrantLock</code> 的 <code>lockInterruptibly()</code> 操作</p>
<p>修改上个示例中的 <code>execute()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">execute</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 略...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot;被中断&quot;</span>);</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="newCondition-方法"><a href="#newCondition-方法" class="headerlink" title="newCondition 方法"></a>newCondition 方法</h4><p><code>newCondition()</code> - 返回一个绑定到 <code>Lock</code> 对象上的 <code>Condition</code> 实例。<code>Condition</code> 的特性和具体方法请阅读<a href="/posts/6216bb38.html#Condition" title="Java锁">🚀Condition</a>。</p>
<h3 id="ReentrantLock-的原理"><a href="#ReentrantLock-的原理" class="headerlink" title="ReentrantLock 的原理"></a>ReentrantLock 的原理</h3><p>ReentrantLock 通过内存屏障和 happens-before 关系来保证可见性。</p>
<p><code>happens-before</code> 是 Java 内存模型（JMM）中的核心概念，它定义了操作之间的内存可见性保证，是理解 Java 并发编程的基础。</p>
<p><strong>什么是 Happens-Before？</strong><br>Happens-Before 关系表示：如果操作 A happens-before 操作 B，那么：</p>
<ul>
<li>A 操作的结果对 B 操作可见</li>
<li>A 操作按顺序排在 B 操作之前</li>
</ul>
<blockquote>
<p>🔔注意：这并不一定意味着在时间上 A 真的在 B 之前执行，而是指从内存可见性的角度来看，A 的效果对 B 是可见的。</p>
</blockquote>
<h2 id="ReentrantReadWriteLock"><a href="#ReentrantReadWriteLock" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h2><p>当读操作远远高于写操作时，这时候使用 <code>读写锁</code> 让 <code>读-读</code> 可以并发，提高性能。 类似于数据库中的 <code>select ...from ... lock in share mode</code></p>
<p>提供一个 <code>数据容器类</code> 内部分别使用读锁保护数据的 <code>read()</code> 方法，写锁保护数据的<code>write()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 读锁-读锁 可以并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出结果，从这里可以看到 t2 锁定期间，t1 的读操作不受影响</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:05:14.341 c.DataContainer [t2] - 获取读锁... </span><br><span class="line">14:05:14.341 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:05:14.345 c.DataContainer [t1] - 读取 </span><br><span class="line">14:05:14.345 c.DataContainer [t2] - 读取 </span><br><span class="line">14:05:15.365 c.DataContainer [t2] - 释放读锁... </span><br><span class="line">14:05:15.386 c.DataContainer [t1] - 释放读锁..</span><br></pre></td></tr></table></figure>

<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:04:21.838 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:04:21.838 c.DataContainer [t2] - 获取写锁... </span><br><span class="line">14:04:21.841 c.DataContainer [t2] - 写入 </span><br><span class="line">14:04:22.843 c.DataContainer [t2] - 释放写锁... </span><br><span class="line">14:04:22.843 c.DataContainer [t1] - 读取 </span><br><span class="line">14:04:23.843 c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>
<p>写锁-写锁 也是相互阻塞的</p>
<blockquote>
<p>🔔注意：</p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
</blockquote>
<h2 id="StampedLock"><a href="#StampedLock" class="headerlink" title="StampedLock"></a>StampedLock</h2><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用<br>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法（乐观读），读取完毕后需要做一次 <code>戳校验</code> 如果校验通<br>过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <br>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试 读-读 可以优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果，可以看到实际没有加读锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15:58:50.217 c.DataContainerStamped [t1] - optimistic read locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - optimistic read locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - read finish...256, data:1 </span><br><span class="line">15:58:51.220 c.DataContainerStamped [t1] - read finish...256, data:1</span><br></pre></td></tr></table></figure>

<p>测试 读-写 时优化读补加读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:57:00.219 c.DataContainerStamped [t1] - optimistic read locking...256 </span><br><span class="line">15:57:00.717 c.DataContainerStamped [t2] - write lock 384 </span><br><span class="line">15:57:01.225 c.DataContainerStamped [t1] - updating to read lock... 256 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t1] - read lock 513 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - read finish...513, data:1000 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - read unlock 513 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔注意：</p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
</blockquote>
<h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><blockquote>
<p><code>AbstractQueuedSynchronizer</code>（简称 <strong>AQS</strong>）是<strong>队列同步器</strong>，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>CountDownLatch</code>、<code>Semaphore</code>、<code>FutureTask</code> 等）。</p>
</blockquote>
<h3 id="AQS-的要点"><a href="#AQS-的要点" class="headerlink" title="AQS 的要点"></a>AQS 的要点</h3><p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。</p>
<p>在 <code>java.util.concurrent.locks</code> 包中的相关锁（常用的有 <code>ReentrantLock</code>、 <code>ReadWriteLock</code>）都是基于 AQS 来实现。这些锁都没有直接继承 AQS，而是定义了一个 <code>Sync</code> 类去继承 AQS。为什么要这样呢？因为锁面向的是使用用户，而同步器面向的则是线程控制，那么在锁的实现中聚合同步器而不是直接继承 AQS 就可以很好的隔离二者所关注的事情。</p>
<h3 id="AQS-的应用"><a href="#AQS-的应用" class="headerlink" title="AQS 的应用"></a>AQS 的应用</h3><p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。</p>
<h4 id="独享锁-API"><a href="#独享锁-API" class="headerlink" title="独享锁 API"></a>独享锁 API</h4><p>获取、释放独享锁的主要 API 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquire</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">release</span><span class="params">(<span class="type">int</span> arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquire</code> - 获取独占锁。</li>
<li><code>acquireInterruptibly</code> - 获取可中断的独占锁。</li>
<li><code>tryAcquireNanos</code> - 尝试在指定时间内获取可中断的独占锁。在以下三种情况下回返回：<ul>
<li>在超时时间内，当前线程成功获取了锁；</li>
<li>当前线程在超时时间内被中断；</li>
<li>超时时间结束，仍未获得锁返回 false。</li>
</ul>
</li>
<li><code>release</code> - 释放独占锁。</li>
</ul>
<h4 id="共享锁-API"><a href="#共享锁-API" class="headerlink" title="共享锁 API"></a>共享锁 API</h4><p>获取、释放共享锁的主要 API 如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">acquireSharedInterruptibly</span><span class="params">(<span class="type">int</span> arg)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">tryAcquireSharedNanos</span><span class="params">(<span class="type">int</span> arg, <span class="type">long</span> nanosTimeout)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">releaseShared</span><span class="params">(<span class="type">int</span> arg)</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>acquireShared</code> - 获取共享锁。</li>
<li><code>acquireSharedInterruptibly</code> - 获取可中断的共享锁。</li>
<li><code>tryAcquireSharedNanos</code> - 尝试在指定时间内获取可中断的共享锁。</li>
<li><code>release</code> - 释放共享锁。</li>
</ul>
<h3 id="AQS-的原理"><a href="#AQS-的原理" class="headerlink" title="AQS 的原理"></a>AQS 的原理</h3><blockquote>
<p>ASQ 原理要点：</p>
<ul>
<li>AQS 使用一个整型的 <code>volatile</code> 变量来 <strong>维护同步状态</strong>。状态的意义由子类赋予。</li>
<li>AQS 维护了一个 FIFO 的双链表，用来存储获取锁失败的线程。</li>
</ul>
<p>AQS 围绕同步状态提供两种基本操作“获取”和“释放”，并提供一系列判断和处理方法，简单说几点：</p>
<ul>
<li>state 是独占的，还是共享的；</li>
<li>state 被获取后，其他线程需要等待；</li>
<li>state 被释放后，唤醒等待线程；</li>
<li>线程等不及时，如何退出等待。</li>
</ul>
<p>至于线程是否可以获得 state，如何释放 state，就不是 AQS 关心的了，要由子类具体实现。</p>
</blockquote>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁 <code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:22:06.962 [t2] c.TestDeadLock - lock B </span><br><span class="line">12:22:06.962 [t1] c.TestDeadLock - lock A</span><br></pre></td></tr></table></figure>

<h2 id="活锁"><a href="#活锁" class="headerlink" title="活锁"></a>活锁</h2><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h2><h3 id="synchronized解决方案"><a href="#synchronized解决方案" class="headerlink" title="synchronized解决方案"></a>synchronized解决方案</h3><p>可以使用 synchronized 来解决上述共享带来的问题，俗称<strong>对象锁</strong>，它采用互斥的方式让同一时刻至多只有一个线程能持有对象锁，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<blockquote>
<p>🔔注意：<br>虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的：</p>
<ul>
<li>互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码</li>
<li>同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点</li>
</ul>
</blockquote>
<p>语法：</p>
<p>解决<strong>共享带来的问题</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(room) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">5000</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(room) &#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法上的synchronized"><a href="#方法上的synchronized" class="headerlink" title="方法上的synchronized"></a>方法上的synchronized</h3><h3 id="变量的线程安全分析"><a href="#变量的线程安全分析" class="headerlink" title="变量的线程安全分析"></a>变量的线程安全分析</h3><p><strong>成员变量和静态变量是否线程安全？</strong></p>
<ul>
<li>如果它们没有共享，则线程安全</li>
<li>如果它们被共享了，根据它们的状态是否能够改变，又分两种情况<ul>
<li>如果只有读操作，则线程安全</li>
<li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li>
</ul>
</li>
</ul>
<p><strong>局部变量是否线程安全？</strong></p>
<ul>
<li>局部变量是线程安全的</li>
<li>但局部变量引用的对象则未必<ul>
<li>如果该对象没有逃离方法的作用访问，它是线程安全的</li>
<li>如果该对象逃离方法的作用范围，需要考虑线程安全</li>
</ul>
</li>
</ul>
<h3 id="Park-Unpark"><a href="#Park-Unpark" class="headerlink" title="Park&amp;Unpark"></a>Park&amp;Unpark</h3><p><strong>基本使用</strong><br>它们是 LockSupport 类中的方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暂停当前线程</span></span><br><span class="line">LockSupport.park(); </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 恢复某个线程的运行</span></span><br><span class="line">LockSupport.unpark(暂停线程对象)</span><br></pre></td></tr></table></figure>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    log.debug(<span class="string">&quot;park...&quot;</span>);</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    log.debug(<span class="string">&quot;resume...&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">sleep(<span class="number">2</span>);</span><br><span class="line">log.debug(<span class="string">&quot;unpark...&quot;</span>);</span><br><span class="line">LockSupport.unpark(t1)</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:42:52.585 c.TestParkUnpark [t1] - start... </span><br><span class="line">18:42:53.589 c.TestParkUnpark [t1] - park... </span><br><span class="line">18:42:54.583 c.TestParkUnpark [main] - unpark... </span><br><span class="line">18:42:54.583 c.TestParkUnpark [t1] - resume...</span><br></pre></td></tr></table></figure>

<p><strong>特点</strong><br>与 Object 的 wait &amp; notify 相比</p>
<ul>
<li>wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必</li>
<li>park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li>park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify</li>
</ul>
<h3 id="死锁-1"><a href="#死锁-1" class="headerlink" title="死锁"></a>死锁</h3><p>有这样的情况：一个线程需要同时获取多把锁，这时就容易发生死锁<br><code>t1 线程</code> 获得 <code>A对象</code> 锁，接下来想获取 <code>B对象</code> 的锁 <code>t2 线程</code> 获得 <code>B对象</code> 锁，接下来想获取 <code>A对象</code> 的锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(B) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;lock B&quot;</span>);</span><br><span class="line">        sleep(<span class="number">0.5</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(A) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;lock A&quot;</span>);</span><br><span class="line">            log.debug(<span class="string">&quot;操作...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line">t2.start();</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12:22:06.962 [t2] c.TestDeadLock - lock B </span><br><span class="line">12:22:06.962 [t1] c.TestDeadLock - lock A</span><br></pre></td></tr></table></figure>

<h3 id="活锁-1"><a href="#活锁-1" class="headerlink" title="活锁"></a>活锁</h3><p>活锁出现在两个线程互相改变对方的结束条件，最后谁也无法结束，例如</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestLiveLock</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望减到 0 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count--;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 期望超过 20 退出循环</span></span><br><span class="line">            <span class="keyword">while</span> (count &lt; <span class="number">20</span>) &#123;</span><br><span class="line">                sleep(<span class="number">0.2</span>);</span><br><span class="line">                count++;</span><br><span class="line">                log.debug(<span class="string">&quot;count: &#123;&#125;&quot;</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReentrantLock-1"><a href="#ReentrantLock-1" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h3><p>相对于 synchronized 它具备如下特点</p>
<ul>
<li>可中断</li>
<li>可以设置超时时间</li>
<li>可以设置为公平锁</li>
<li>支持多个条件变量</li>
</ul>
<p>与 synchronized 一样，都支持可重入</p>
<p>基本语法:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取锁</span></span><br><span class="line">reentrantLock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"> <span class="comment">// 临界区</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line"> <span class="comment">// 释放锁</span></span><br><span class="line"> reentrantLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="可重入"><a href="#可重入" class="headerlink" title="可重入"></a>可重入</h5><p>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁。如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>);</span><br><span class="line">        method2();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>);</span><br><span class="line">        method3();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">execute mothod1</span><br><span class="line">execute mothod2</span><br><span class="line">execute mothod3</span><br></pre></td></tr></table></figure>

<h5 id="可打断"><a href="#可打断" class="headerlink" title="可打断"></a>可打断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">//注意如果是不可中断模式，那么即使使用了 interrupt 也不会让等待中断</span></span><br><span class="line">        lock.lockInterruptibly();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt();</span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁 </span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断 </span><br><span class="line">java.lang.InterruptedException </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr</span><br><span class="line">onizer.java:898) </span><br><span class="line"> at </span><br><span class="line">java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron</span><br><span class="line">izer.java:1222) </span><br><span class="line"> at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) </span><br><span class="line"> at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17) </span><br><span class="line"> at java.lang.Thread.run(Thread.java:748) </span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断 </span><br></pre></td></tr></table></figure>

<h5 id="锁超时"><a href="#锁超时" class="headerlink" title="锁超时"></a>锁超时</h5><p>立刻失败</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    <span class="comment">//tryLock(1, TimeUnit.SECONDS) 可以设置定时</span></span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁 </span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动... </span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure>

<h5 id="公平锁"><a href="#公平锁" class="headerlink" title="公平锁"></a>公平锁</h5><p><strong>ReentrantLock 默认是不公平的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">false</span>);<span class="comment">//不公平</span></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">500</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, <span class="string">&quot;t&quot;</span> + i).start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1s 之后去争抢锁</span></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(Thread.currentThread().getName() + <span class="string">&quot; start...&quot;</span>);</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        System.out.println(Thread.currentThread().getName() + <span class="string">&quot; running...&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;强行插入&quot;</span>).start();</span><br><span class="line">lock.unlock();</span><br></pre></td></tr></table></figure>
<p>强行插入，有机会在中间输出</p>
<blockquote>
<p>🔔注意：该实验不一定总能复现</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">t39 running... </span><br><span class="line">t40 running... </span><br><span class="line">t41 running... </span><br><span class="line">t42 running... </span><br><span class="line">t43 running... </span><br><span class="line">强行插入 start... </span><br><span class="line">强行插入 running... </span><br><span class="line">t44 running... </span><br><span class="line">t45 running... </span><br><span class="line">t46 running... </span><br><span class="line">t47 running... </span><br><span class="line">t49 running...</span><br></pre></td></tr></table></figure>
<p>改为公平锁后:<code>ReentrantLock lock = new ReentrantLock(true);</code><br>强行插入，总是在最后输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">t465 running... </span><br><span class="line">t464 running... </span><br><span class="line">t477 running... </span><br><span class="line">t442 running... </span><br><span class="line">t468 running... </span><br><span class="line">t493 running... </span><br><span class="line">t482 running... </span><br><span class="line">t485 running... </span><br><span class="line">t481 running... </span><br><span class="line">强行插入 running...</span><br></pre></td></tr></table></figure>
<p><strong>公平锁一般没有必要，会降低并发度</strong></p>
<h5 id="条件变量"><a href="#条件变量" class="headerlink" title="条件变量"></a>条件变量</h5><p>synchronized 中也有条件变量，通过 <code>wait&amp;notify&amp;notifyAll</code> 实现的。</p>
<p>ReentrantLock 的条件变量是通过 <code>Condition（await、signal、signalAll）</code> 接口实现的，它提供了比 synchronized 的 wait&#x2F;notify 更强大和灵活的功能。</p>
<p>Condition 使用要点：</p>
<ul>
<li>await 前需要获得锁</li>
<li>await 执行后，会释放锁，进入 conditionObject 等待</li>
<li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 await 后继续执行</li>
</ul>
<p>eg:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitbreakfastQueue</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasCigrette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="type">boolean</span> <span class="variable">hasBreakfast</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasCigrette) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitCigaretteQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的烟&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">while</span> (!hasBreakfast) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    waitbreakfastQueue.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            log.debug(<span class="string">&quot;等到了它的早餐&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendBreakfast();</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    sendCigarette();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendCigarette</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送烟来了&quot;</span>);</span><br><span class="line">        hasCigrette = <span class="literal">true</span>;</span><br><span class="line">        waitCigaretteQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sendBreakfast</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;送早餐来了&quot;</span>);</span><br><span class="line">        hasBreakfast = <span class="literal">true</span>;</span><br><span class="line">        waitbreakfastQueue.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">18:52:27.680 [main] c.TestCondition - 送早餐来了 </span><br><span class="line">18:52:27.682 [Thread-1] c.TestCondition - 等到了它的早餐 </span><br><span class="line">18:52:28.683 [main] c.TestCondition - 送烟来了 </span><br><span class="line">18:52:28.683 [Thread-0] c.TestCondition - 等到了它的烟 </span><br></pre></td></tr></table></figure>
<h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><blockquote>
<p>Memory 要解决共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p>
</blockquote>
<h4 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h4><p>JMM 即 Java Memory Model，它定义了主存、工作内存抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、CPU 指令优化等。<br>JMM 体现在以下几个方面</p>
<ul>
<li>原子性 - 保证指令不会受到线程上下文切换的影响</li>
<li>可见性 - 保证指令不会受 cpu 缓存的影响</li>
<li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li>
</ul>
<h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p><strong>退不出的循环</strong></p>
<p>先来看一个现象，main 线程对 run 变量的修改对于 t 线程不可见，导致了 t 线程无法停止：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">while</span> (run) &#123;</span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    t.start();</span><br><span class="line"></span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    run = <span class="literal">false</span>; <span class="comment">// 线程t不会如预想的停下来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为什么呢？分析一下：</p>
<ol>
<li>初始状态， t 线程刚开始从主内存读取了 run 的值到工作内存。</li>
<li>因为 t 线程要频繁从主内存中读取 run 的值，JIT 编译器会将 run 的值缓存至自己工作内存中的<strong>高速缓存</strong>中，减少对主存中 run 的访问，提高效率。</li>
<li>1 秒之后，main 线程修改了 run 的值，并同步至主存，而 t 线程是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值</li>
</ol>
<p><strong>解决方法</strong></p>
<p><strong>volatile</strong>（易变关键字）</p>
<p>它可以用来修饰<strong>成员变量</strong>和<strong>静态成员变量</strong>，他可以避免线程从自己的工作缓存中查找变量的值，必须到主存中获取<br>它的值，线程操作 volatile 变量都是直接操作主存。</p>
<p><strong>可见性 vs 原子性</strong><br>前面例子体现的实际就是可见性，它保证的是在多个线程之间，<strong>一个线程对 volatile 变量的修改对另一个线程可见</strong>， 不能保证原子性，仅用在一个写线程，多个读线程的情况。</p>
<p>比较一下之前我们将线程安全时举的例子：两个线程一个 <code>i++</code> 一个 <code>i--</code> ，只能保证看到最新值，不能解决指令交错。</p>
<blockquote>
<p>🔔注意：synchronized 语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性。但缺点是 synchronized 是属于重量级操作，性能相对更低<br>如果在前面示例的死循环中加入 System.out.println() 会发现即使不加 volatile 修饰符，线程 t 也能正确看到对 run 变量的修改了，想一想为什么？</p>
</blockquote>
<p>这是因为 System.out.println() 的内部实现实际上起到了<strong>内存屏障（Memory Barrier）</strong> 的作用。运行到<code>System.out.println()</code>语句会刷新<strong>高速缓存</strong>。</p>
<h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>JVM 会在不影响正确性的前提下，可以调整语句的执行顺序</p>
<p>而<strong>volatile 修饰的变量，可以禁用指令重排</strong></p>
<h5 id="happens-before"><a href="#happens-before" class="headerlink" title="happens-before"></a>happens-before</h5><p><code>happens-before</code> 是 Java 内存模型（JMM）中的核心概念，它定义了操作之间的内存可见性保证，是理解 Java 并发编程的基础。</p>
<p><strong>什么是 Happens-Before？</strong><br>Happens-Before 关系表示：如果操作 A happens-before 操作 B，那么：</p>
<ul>
<li>A 操作的结果对 B 操作可见</li>
<li>A 操作按顺序排在 B 操作之前</li>
</ul>
<blockquote>
<p>🔔注意：这并不一定意味着在时间上 A 真的在 B 之前执行，而是指从内存可见性的角度来看，A 的效果对 B 是可见的。</p>
</blockquote>
<h3 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h3><p><strong>final</strong></p>
<ul>
<li>属性用 ﬁnal 修饰保证了该属性是只读的，不能修改</li>
<li>类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性</li>
</ul>
<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h5><a href="/posts/b8b0eacd" title="java 基础">自定义线程池ThreadPoolExecutor</a>

<h5 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork&amp;Join"></a>Fork&amp;Join</h5><p><strong>概念</strong><br>Fork&#x2F;Join 是 JDK 1.7 加入的新的线程池实现，它体现的是一种<strong>分治思想</strong>，适用于能够进行任务拆分的 cpu 密集型<br>运算。<br>所谓的任务拆分，是将一个大任务拆分为算法上相同的小任务，直至不能拆分可以直接求解。跟递归相关的一些计<br>算，如归并排序、斐波那契数列、都可以用分治思想进行求解。</p>
<p>Fork&#x2F;Join 在分治的基础上加入了多线程，可以把每个任务的分解和合并交给不同的线程来完成，进一步提升了运<br>算效率</p>
<p><strong>Fork&#x2F;Join 默认会创建与 cpu 核心数大小相同的线程池</strong></p>
<p><strong>使用</strong><br>提交给 Fork&#x2F;Join 线程池的任务需要继承 RecursiveTask（有返回值）或 RecursiveAction（没有返回值），例如下<br>面定义了一个对 1~n 之间的整数求和的任务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.AddTask&quot;)</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AddTask1</span> <span class="keyword">extends</span> <span class="title class_">RecursiveTask</span> &lt; Integer &gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AddTask1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&quot;</span> + n + <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Integer <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 n 已经为 1，可以求得结果了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;join() &#123;&#125;&quot;</span>, n);</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将任务进行拆分(fork)</span></span><br><span class="line">        <span class="type">AddTask1</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AddTask1</span>(n - <span class="number">1</span>);</span><br><span class="line">        t1.fork();</span><br><span class="line">        log.debug(<span class="string">&quot;fork() &#123;&#125; + &#123;&#125;&quot;</span>, n, t1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 合并(join)结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> n + t1.join();</span><br><span class="line">        log.debug(<span class="string">&quot;join() &#123;&#125; + &#123;&#125; = &#123;&#125;&quot;</span>, n, t1, result);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后提交给 ForkJoinPool 来执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> <span class="type">ForkJoinPool</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ForkJoinPool</span>(<span class="number">4</span>);</span><br><span class="line"> System.out.println(pool.invoke(<span class="keyword">new</span> <span class="title class_">AddTask1</span>(<span class="number">5</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[ForkJoinPool-1-worker-0] - fork() 2 + &#123;1&#125; </span><br><span class="line">[ForkJoinPool-1-worker-1] - fork() 5 + &#123;4&#125; </span><br><span class="line">[ForkJoinPool-1-worker-0] - join() 1 </span><br><span class="line">[ForkJoinPool-1-worker-0] - join() 2 + &#123;1&#125; = 3 </span><br><span class="line">[ForkJoinPool-1-worker-2] - fork() 4 + &#123;3&#125; </span><br><span class="line">[ForkJoinPool-1-worker-3] - fork() 3 + &#123;2&#125; </span><br><span class="line">[ForkJoinPool-1-worker-3] - join() 3 + &#123;2&#125; = 6 </span><br><span class="line">[ForkJoinPool-1-worker-2] - join() 4 + &#123;3&#125; = 10 </span><br><span class="line">[ForkJoinPool-1-worker-1] - join() 5 + &#123;4&#125; = 15 </span><br><span class="line">15</span><br></pre></td></tr></table></figure>

<h4 id="J-U-C"><a href="#J-U-C" class="headerlink" title="J.U.C"></a>J.U.C</h4><h5 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h5><p><strong>AQS (AbstractQueuedSynchronizer)</strong> 是 Java 并发包 (<code>java.util.concurrent.locks</code>) 的核心基础框架，它提供了一个<strong>队列同步器</strong>，用于构建锁和其他同步组件。</p>
<p>核心原理<br><strong>用一个数字表示资源数量，用队列管理等待的线程</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心就这3个东西：</span></span><br><span class="line">state = <span class="number">1</span>      <span class="comment">// 资源数量（比如：1把锁）</span></span><br><span class="line">head -&gt; 线程A  <span class="comment">// 排队队列的头</span></span><br><span class="line">tail -&gt; 线程C  <span class="comment">// 排队队列的尾</span></span><br></pre></td></tr></table></figure>
<h6 id="AQS工作流程"><a href="#AQS工作流程" class="headerlink" title="AQS工作流程"></a>AQS工作流程</h6><ol>
<li>获取资源（排队）</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">线程A：我要锁！ → state=1? → 拿到！(state=1)</span><br><span class="line">线程B：我要锁！ → state=1? → 拿不到 → 去排队</span><br><span class="line">线程C：我要锁！ → state=1? → 拿不到 → 去排队</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>释放资源（叫号）</li>
</ol>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线程A：用完啦！ → state=0 → 叫下一个！</span><br><span class="line">线程B：轮到我了！ → state=1 → 拿到！</span><br></pre></td></tr></table></figure>

<p><strong>实现一个简单的锁</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.locks.AbstractQueuedSynchronizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 最简单的锁实现</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SimpleLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 继承AQS，只需要重写2个方法！</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="comment">// 尝试获取锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// CAS操作：如果state是0（没人占用），就改成1（我占用）</span></span><br><span class="line">            <span class="keyword">return</span> compareAndSetState(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 尝试释放锁</span></span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> arg)</span> &#123;</span><br><span class="line">            <span class="comment">// 直接把state设回0（释放锁）</span></span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对外提供的锁方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.acquire(<span class="number">1</span>);    <span class="comment">// AQS帮你处理排队逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123;</span><br><span class="line">        sync.release(<span class="number">1</span>);    <span class="comment">// AQS帮你唤醒下一个线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用这个锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">SimpleLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleLock</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">safeIncrement</span><span class="params">()</span> &#123;</span><br><span class="line">    lock.lock();        <span class="comment">// 获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        count++;        <span class="comment">// 安全操作</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">// 释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="AQS使用时机"><a href="#AQS使用时机" class="headerlink" title="AQS使用时机"></a>AQS使用时机</h6><p>什么时候用 AQS？</p>
<p>需要自己造轮子时：</p>
<ul>
<li>自定义锁</li>
<li>自定义同步工具</li>
<li>特殊资源控制</li>
</ul>
<p><strong>日常开发</strong>：直接用现成的！</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 99%的情况用这些就够了：</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">5</span>);</span><br><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>

<h5 id="ReentrantLock原理"><a href="#ReentrantLock原理" class="headerlink" title="ReentrantLock原理"></a>ReentrantLock原理</h5><p>ReentrantLock的简化版</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这就是ReentrantLock的核心思想！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyReentrantLock</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Sync</span> <span class="variable">sync</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Sync</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Sync</span> <span class="keyword">extends</span> <span class="title class_">AbstractQueuedSynchronizer</span> &#123;</span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryAcquire</span><span class="params">(<span class="type">int</span> acquires)</span> &#123;</span><br><span class="line">            <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">            <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> getState();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 没人占用，我占用</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">                    setExclusiveOwnerThread(current);</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">                <span class="comment">// 重入：我已经占用了，再次获取</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">nextState</span> <span class="operator">=</span> state + acquires;</span><br><span class="line">                setState(nextState);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">protected</span> <span class="type">boolean</span> <span class="title function_">tryRelease</span><span class="params">(<span class="type">int</span> releases)</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">state</span> <span class="operator">=</span> getState() - releases;</span><br><span class="line">            <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalMonitorStateException</span>();</span><br><span class="line">            </span><br><span class="line">            <span class="type">boolean</span> <span class="variable">free</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (state == <span class="number">0</span>) &#123;</span><br><span class="line">                free = <span class="literal">true</span>;</span><br><span class="line">                setExclusiveOwnerThread(<span class="literal">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(state);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">lock</span><span class="params">()</span> &#123; sync.acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">unlock</span><span class="params">()</span> &#123; sync.release(<span class="number">1</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h4><h5 id="ReentrantReadWriteLock-1"><a href="#ReentrantReadWriteLock-1" class="headerlink" title="ReentrantReadWriteLock"></a>ReentrantReadWriteLock</h5><p>当读操作远远高于写操作时，这时候使用 <code>读写锁</code> 让 <code>读-读</code> 可以并发，提高性能。 类似于数据库中的 <code>select ...from ... lock in share mode</code></p>
<p>提供一个 <code>数据容器类</code> 内部分别使用读锁保护数据的 <code>read()</code> 方法，写锁保护数据的<code>write()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainer</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Object data;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">ReentrantReadWriteLock</span> <span class="variable">rw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantReadWriteLock</span>();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">ReadLock</span> <span class="variable">r</span> <span class="operator">=</span> rw.readLock();</span><br><span class="line">    <span class="keyword">private</span> ReentrantReadWriteLock.<span class="type">WriteLock</span> <span class="variable">w</span> <span class="operator">=</span> rw.writeLock();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">read</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取读锁...&quot;</span>);</span><br><span class="line">        r.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;读取&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放读锁...&quot;</span>);</span><br><span class="line">            r.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">()</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取写锁...&quot;</span>);</span><br><span class="line">        w.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;写入&quot;</span>);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;释放写锁...&quot;</span>);</span><br><span class="line">            w.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>测试 读锁-读锁 可以并发</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出结果，从这里可以看到 t2 锁定期间，t1 的读操作不受影响</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:05:14.341 c.DataContainer [t2] - 获取读锁... </span><br><span class="line">14:05:14.341 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:05:14.345 c.DataContainer [t1] - 读取 </span><br><span class="line">14:05:14.345 c.DataContainer [t2] - 读取 </span><br><span class="line">14:05:15.365 c.DataContainer [t2] - 释放读锁... </span><br><span class="line">14:05:15.386 c.DataContainer [t1] - 释放读锁..</span><br></pre></td></tr></table></figure>

<p>测试 读锁-写锁 相互阻塞</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataContainer</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainer</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.read();</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"> </span><br><span class="line">Thread.sleep(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line"> dataContainer.write();</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">14:04:21.838 c.DataContainer [t1] - 获取读锁... </span><br><span class="line">14:04:21.838 c.DataContainer [t2] - 获取写锁... </span><br><span class="line">14:04:21.841 c.DataContainer [t2] - 写入 </span><br><span class="line">14:04:22.843 c.DataContainer [t2] - 释放写锁... </span><br><span class="line">14:04:22.843 c.DataContainer [t1] - 读取 </span><br><span class="line">14:04:23.843 c.DataContainer [t1] - 释放读锁... </span><br></pre></td></tr></table></figure>
<p>写锁-写锁 也是相互阻塞的</p>
<blockquote>
<p>🔔注意：</p>
<ul>
<li>读锁不支持条件变量</li>
<li>重入时升级不支持：即持有读锁的情况下去获取写锁，会导致获取写锁永久等待</li>
<li>重入时降级支持：即持有写锁的情况下去获取读锁</li>
</ul>
</blockquote>
<h5 id="StampedLock-1"><a href="#StampedLock-1" class="headerlink" title="StampedLock"></a>StampedLock</h5><p>该类自 JDK 8 加入，是为了进一步优化读性能，它的特点是在使用读锁、写锁时都必须配合【戳】使用<br>加解读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.readLock();</span><br><span class="line">lock.unlockRead(stamp);</span><br></pre></td></tr></table></figure>

<p>加解写锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">lock.unlockWrite(stamp);</span><br></pre></td></tr></table></figure>

<p>乐观读，StampedLock 支持 <code>tryOptimisticRead()</code> 方法（乐观读），读取完毕后需要做一次 <code>戳校验</code> 如果校验通<br>过，表示这期间确实没有写操作，数据可以安全使用，如果校验没通过，需要重新获取读锁，保证数据安全。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line"><span class="comment">// 验戳</span></span><br><span class="line"><span class="keyword">if</span>(!lock.validate(stamp))&#123;</span><br><span class="line"> <span class="comment">// 锁升级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <br>提供一个 数据容器类 内部分别使用读锁保护数据的 read() 方法，写锁保护数据的 write() 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">DataContainerStamped</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="type">StampedLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StampedLock</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DataContainerStamped</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> readTime)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.tryOptimisticRead();</span><br><span class="line">        log.debug(<span class="string">&quot;optimistic read locking...&#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        sleep(readTime);</span><br><span class="line">        <span class="keyword">if</span> (lock.validate(stamp)) &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 锁升级 - 读锁</span></span><br><span class="line">        log.debug(<span class="string">&quot;updating to read lock... &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stamp = lock.readLock();</span><br><span class="line">            log.debug(<span class="string">&quot;read lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            sleep(readTime);</span><br><span class="line">            log.debug(<span class="string">&quot;read finish...&#123;&#125;, data:&#123;&#125;&quot;</span>, stamp, data);</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;read unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockRead(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> newData)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">stamp</span> <span class="operator">=</span> lock.writeLock();</span><br><span class="line">        log.debug(<span class="string">&quot;write lock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            sleep(<span class="number">2</span>);</span><br><span class="line">            <span class="built_in">this</span>.data = newData;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.debug(<span class="string">&quot;write unlock &#123;&#125;&quot;</span>, stamp);</span><br><span class="line">            lock.unlockWrite(stamp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试 读-读 可以优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">0</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果，可以看到实际没有加读锁</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">15:58:50.217 c.DataContainerStamped [t1] - optimistic read locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - optimistic read locking...256 </span><br><span class="line">15:58:50.717 c.DataContainerStamped [t2] - read finish...256, data:1 </span><br><span class="line">15:58:51.220 c.DataContainerStamped [t1] - read finish...256, data:1</span><br></pre></td></tr></table></figure>

<p>测试 读-写 时优化读补加读锁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">DataContainerStamped</span> <span class="variable">dataContainer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataContainerStamped</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.read(<span class="number">1</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">    sleep(<span class="number">0.5</span>);</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        dataContainer.write(<span class="number">100</span>);</span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">15:57:00.219 c.DataContainerStamped [t1] - optimistic read locking...256 </span><br><span class="line">15:57:00.717 c.DataContainerStamped [t2] - write lock 384 </span><br><span class="line">15:57:01.225 c.DataContainerStamped [t1] - updating to read lock... 256 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t2] - write unlock 384 </span><br><span class="line">15:57:02.719 c.DataContainerStamped [t1] - read lock 513 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - read finish...513, data:1000 </span><br><span class="line">15:57:03.719 c.DataContainerStamped [t1] - read unlock 513 </span><br></pre></td></tr></table></figure>

<blockquote>
<p>🔔注意：</p>
<ul>
<li>StampedLock 不支持条件变量</li>
<li>StampedLock 不支持可重入</li>
</ul>
</blockquote>
<h5 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h5><p>信号量，用来限制能同时访问共享资源的线程上限</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 semaphore 对象</span></span><br><span class="line">    <span class="type">Semaphore</span> <span class="variable">semaphore</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 10个线程同时运行</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="comment">// 3. 获取许可</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                semaphore.acquire();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;running...&quot;</span>);</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">                log.debug(<span class="string">&quot;end...&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 4. 释放许可</span></span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 输出<br> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 07:35:15.485 c.TestSemaphore [Thread-2] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-1] - running... </span><br><span class="line">07:35:15.485 c.TestSemaphore [Thread-0] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-2] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-0] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-1] - end... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-3] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-5] - running... </span><br><span class="line">07:35:16.490 c.TestSemaphore [Thread-4] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-5] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-4] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-3] - end... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-6] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-7] - running... </span><br><span class="line">07:35:17.490 c.TestSemaphore [Thread-9] - running... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-6] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-7] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-9] - end... </span><br><span class="line">07:35:18.491 c.TestSemaphore [Thread-8] - running... </span><br><span class="line">07:35:19.492 c.TestSemaphore [Thread-8] - end... </span><br></pre></td></tr></table></figure></p>
<h5 id="CountdownLatch"><a href="#CountdownLatch" class="headerlink" title="CountdownLatch"></a>CountdownLatch</h5><p>用来进行线程同步协作，等待所有线程完成倒计时。<br>其中构造参数用来初始化等待计数值，await() 用来等待计数归零，countDown() 用来让计数减一</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);  <span class="comment">// 初始计数=3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程完成任务时：</span></span><br><span class="line">latch.countDown();  <span class="comment">// 计数减1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等待的线程：</span></span><br><span class="line">latch.await();      <span class="comment">// 阻塞，直到计数=0</span></span><br></pre></td></tr></table></figure>

<p>eg：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">CountDownLatch</span> <span class="variable">latch</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountDownLatch</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;begin...&quot;</span>);</span><br><span class="line">        sleep(<span class="number">1.5</span>);</span><br><span class="line">        latch.countDown();</span><br><span class="line">        log.debug(<span class="string">&quot;end...&#123;&#125;&quot;</span>, latch.getCount());</span><br><span class="line">    &#125;).start();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">&quot;waiting...&quot;</span>);</span><br><span class="line">    latch.await();</span><br><span class="line">    log.debug(<span class="string">&quot;wait end...&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">18:44:00.778 c.TestCountDownLatch [main] - waiting... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-2] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-0] - begin... </span><br><span class="line">18:44:00.778 c.TestCountDownLatch [Thread-1] - begin... </span><br><span class="line">18:44:01.782 c.TestCountDownLatch [Thread-0] - end...2 </span><br><span class="line">18:44:02.283 c.TestCountDownLatch [Thread-2] - end...1 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [Thread-1] - end...0 </span><br><span class="line">18:44:02.782 c.TestCountDownLatch [main] - wait end...</span><br></pre></td></tr></table></figure>
<h5 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h5><p>循环栅栏，用来进行线程协作，等待线程满足某个计数。构造时设置『计数个数』，每个线程执行到某个需要“同步”的时刻调用 await() 方法进行等待，当等待的线程数满足『计数个数』时，继续执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">CyclicBarrier</span> <span class="variable">cb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CyclicBarrier</span>(<span class="number">2</span>); <span class="comment">// 个数为2时才会继续执行</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1开始..&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 当个数不足时，等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程1继续向下运行...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2开始..&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;&#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.await(); <span class="comment">// 2 秒后，线程个数够2，继续运行</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException | BrokenBarrierException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;线程2继续向下运行...&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<blockquote>
<p>🔔注意： CyclicBarrier 与 CountDownLatch 的主要区别在于 CyclicBarrier 是可以重用的， CyclicBarrier 可以被比喻为『人满发车』</p>
</blockquote>
<h5 id="线程安全集合类概述"><a href="#线程安全集合类概述" class="headerlink" title="线程安全集合类概述"></a>线程安全集合类概述</h5><p>线程安全集合类可以分为三大类：</p>
<ol>
<li>遗留的线程安全集合</li>
</ol>
<ul>
<li>Hashtable</li>
<li>Vector</li>
</ul>
<ol start="2">
<li>使用 Collections 装饰的线程安全集合</li>
</ol>
<ul>
<li>Collections.synchronizedCollection</li>
<li>Collections.synchronizedList</li>
<li>Collections.synchronizedMap</li>
<li>Collections.synchronizedSet</li>
<li>Collections.synchronizedNavigableMap</li>
<li>Collections.synchronizedNavigableSet</li>
<li>Collections.synchronizedSortedMap</li>
<li>Collections.synchronizedSortedSet</li>
</ul>
<ol start="3">
<li>java.util.concurrent.*</li>
</ol>
<p>重点介绍 <code>java.util.concurrent.*</code> 下的线程安全集合类，可以发现它们有规律，里面包含三类关键词：<strong>Blocking</strong>、<strong>CopyOnWrite</strong>、<strong>Concurrent</strong></p>
<ul>
<li><p>Blocking 大部分实现基于锁，并提供用来阻塞的方法</p>
</li>
<li><p>CopyOnWrite 修改开销相对较重</p>
</li>
<li><p>Concurrent 类型的容器</p>
</li>
<li><p>内部很多操作使用 CAS 优化，一般可以提供较高吞吐量</p>
</li>
<li><p>弱一致性</p>
<ul>
<li>遍历时弱一致性：当利用迭代器遍历时，如果容器发生修改，迭代器仍然可以继续进行遍历，这时内容是旧的</li>
<li>求大小弱一致性：size 操作未必是 100% 准确</li>
<li>读取弱一致性</li>
</ul>
</li>
</ul>
<blockquote>
<p>遍历时如果发生了修改，对于非安全容器来讲，使用 fail-fast 机制也就是让遍历立刻失败，抛出ConcurrentModiﬁcationException，不再继续遍历</p>
</blockquote>
<h5 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h5><h5 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h5><h5 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h5></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://coder-xuyong.github.io">coder-xuyong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://coder-xuyong.github.io/posts/6216bb38">https://coder-xuyong.github.io/posts/6216bb38</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://coder-xuyong.github.io" target="_blank">coder-xuyong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a><a class="post-meta__tags" href="/tags/%E5%B9%B6%E5%8F%91/">并发</a></div><div class="post-share"><div class="social-share" data-image="https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/19b32c42" title="Java并发工具类"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dcdad1b7aa454b97b412899068f94aa620250313.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">Java并发工具类</div></div><div class="info-2"><div class="info-item-1">Java 并发工具类 JDK 的 java.util.concurrent 包（即 J.U.C）中提供了几个非常有用的并发工具类。  CountDownLatch 字面意思为 递减计数锁。用于控制一个线程等待多个线程。 CountDownLatch 维护一个计数器 count，表示需要等待的事件数量。countDown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。  CountDownLatch 是基于 AQS(AbstractQueuedSynchronizer) 实现的。 CountDownLatch 唯一的构造方法： 12// 初始化计数器public CountDownLatch(int count) &#123;&#125;;  说明：  count 为统计值。  CountDownLatch 的重要方法： 123public void await() throws InterruptedException &#123; &#125;;public boolean await(long...</div></div></div></a><a class="pagination-related" href="/posts/7ea96e03" title="Java并发和容器"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dbc6de3bf3ec4db59f8ca4288cfa3e3c20250507.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Java并发和容器</div></div><div class="info-2"><div class="info-item-1">Java 并发和容器同步容器同步容器简介在 Java 中，同步容器主要包括 2 类：  Vector、Stack、Hashtable Vector - Vector 实现了 List 接口。Vector 实际上就是一个数组，和 ArrayList 类似。但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。 Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。 Hashtable- Hashtable 实现了 Map 接口，它和 HashMap 很相似，但是 Hashtable 进行了同步处理，而 HashMap 没有。   Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXXX 等方法）  同步容器的问题同步容器的同步原理就是在其 get、set、size 等主要方法上用 synchronized 修饰。 性能问题synchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 syn...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/32d96a2b" title="Java并发简介"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/5803ca9faed74b0080a1156e0ef93aae20250529.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-15</div><div class="info-item-2">Java并发简介</div></div><div class="info-2"><div class="info-item-1">并发概念进程和线程 进程： 可以视为程序的一个实例。  线程： 线程作为最小调度单位，进程作为资源分配的最小单位。  一个进程之内可以分为一到多个线程。  一个线是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行  Java 中，线程作为最小调度单位，进程作为资源分配的最小单位。 在 windows 中进程是不活动的，只是作为线程的容器。   进程和线程的差异：  一个程序至少有一个进程，一个进程至少有一个线程。 线程比进程划分更细，所以执行开销更小，并发性更高 进程是一个实体，拥有独立的资源；而同一个进程中的资源是多个线程共享的。  并行与并发单核 cpu 下，线程实际还是串行执行的。操作系统中有一个组件叫做任务调度器，将 cpu 的时间片（windows下时间片最小约为 15 毫秒）分给不同的程序使用，只是由于 cpu 在线程间（时间片很短）的切换非常快，人类感觉是 同时运行的 。总结为一句话就是： 微观串行，宏观并行 ，一般会将这种 线程轮流使用 CPU 的做法称为并发， concurrent    cpu 时间片1 时间片2 时间片3 时间片4    co...</div></div></div></a><a class="pagination-related" href="/posts/b9e487ed" title="Java并发核心机制"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/f59dff6fb93d4904b442d315738e6a6420250507.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-16</div><div class="info-item-2">Java并发核心机制</div></div><div class="info-2"><div class="info-item-1">Java 并发核心机制 Java 对于并发的支持主要汇聚在 java.util.concurrent，即 J.U.C。而 J.U.C 的核心是 AQS。  J.U.C 简介Java 的 java.util.concurrent 包（简称 J.U.C）中提供了大量并发工具类，是 Java 并发能力的主要体现（注意，不是全部，有部分并发能力的支持在其他包中）。从功能上，大致可以分为：  原子类 - 如：AtomicInteger、AtomicIntegerArray、AtomicReference、AtomicStampedReference 等。 锁 - 如：ReentrantLock、ReentrantReadWriteLock 等。 并发容器 - 如：ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet 等。 阻塞队列 - 如：ArrayBlockingQueue、LinkedBlockingQueue 等。 非阻塞队列 - 如： ConcurrentLinkedQueue 、LinkedTransferQueue...</div></div></div></a><a class="pagination-related" href="/posts/7ea96e03" title="Java并发和容器"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dbc6de3bf3ec4db59f8ca4288cfa3e3c20250507.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-17</div><div class="info-item-2">Java并发和容器</div></div><div class="info-2"><div class="info-item-1">Java 并发和容器同步容器同步容器简介在 Java 中，同步容器主要包括 2 类：  Vector、Stack、Hashtable Vector - Vector 实现了 List 接口。Vector 实际上就是一个数组，和 ArrayList 类似。但是 Vector 中的方法都是 synchronized 方法，即进行了同步措施。 Stack - Stack 也是一个同步容器，它的方法也用 synchronized 进行了同步，它实际上是继承于 Vector 类。 Hashtable- Hashtable 实现了 Map 接口，它和 HashMap 很相似，但是 Hashtable 进行了同步处理，而 HashMap 没有。   Collections 类中提供的静态工厂方法创建的类（由 Collections.synchronizedXXX 等方法）  同步容器的问题同步容器的同步原理就是在其 get、set、size 等主要方法上用 synchronized 修饰。 性能问题synchronized 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 syn...</div></div></div></a><a class="pagination-related" href="/posts/19b32c42" title="Java并发工具类"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dcdad1b7aa454b97b412899068f94aa620250313.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-17</div><div class="info-item-2">Java并发工具类</div></div><div class="info-2"><div class="info-item-1">Java 并发工具类 JDK 的 java.util.concurrent 包（即 J.U.C）中提供了几个非常有用的并发工具类。  CountDownLatch 字面意思为 递减计数锁。用于控制一个线程等待多个线程。 CountDownLatch 维护一个计数器 count，表示需要等待的事件数量。countDown 方法递减计数器，表示有一个事件已经发生。调用 await 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。  CountDownLatch 是基于 AQS(AbstractQueuedSynchronizer) 实现的。 CountDownLatch 唯一的构造方法： 12// 初始化计数器public CountDownLatch(int count) &#123;&#125;;  说明：  count 为统计值。  CountDownLatch 的重要方法： 123public void await() throws InterruptedException &#123; &#125;;public boolean await(long...</div></div></div></a><a class="pagination-related" href="/posts/91e798bc" title="Java内存模型"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/5803ca9faed74b0080a1156e0ef93aae20250529.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-18</div><div class="info-item-2">Java内存模型</div></div><div class="info-2"><div class="info-item-1">Java 内存模型 关键词：JMM、volatile、synchronized、final、Happens-Before、内存屏障 Java 内存模型（Java Memory Model），简称 JMM。Java 内存模型的目标是为了解决由可见性和有序性导致的并发安全问题。Java 内存模型通过 屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。  物理内存模型物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现也有相当大的参考意义。 硬件处理效率物理内存的第一个问题是：硬件处理效率。  绝大多数的运算任务都不可能只靠处理器“计算”就能完成，处理器至少需要与内存交互，如读取运算数据、存储运算结果，这个 I&#x2F;O 操作是很难消除的（无法仅靠寄存器完成所有运算任务）。 由于计算机的存储设备与处理器的运算速度有几个数量级的差距 ，这种速度上的矛盾，会降低硬件的处理效率。所以，现代计算机都不得不 加入高速缓存（Cache） 来作为内存和处理器之间的缓冲。将需要用到的数据复制到缓存中，让运算能...</div></div></div></a><a class="pagination-related" href="/posts/c16f2ba9" title="ForkJoin框架"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/7f933184dd4747a0bb326ff1bca1eda720250730.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-10-18</div><div class="info-item-2">ForkJoin框架</div></div><div class="info-2"><div class="info-item-1">Java Fork Join 框架对于简单的并行任务，你可以通过“线程池 +Future”的方案来解决；如果任务之间有聚合关系，无论是 AND 聚合还是 OR 聚合，都可以通过 CompletableFuture 来解决；而批量的并行任务，则可以通过 CompletionService 来解决。 CompletableFuturerunAsync 和 supplyAsync 方法CompletableFuture 提供了四个静态方法来创建一个异步操作。 1234public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)public static...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/medias/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">coder-xuyong</div><div class="author-info-description">生如牛马不得闲</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">100</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">97</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">45</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/coder-xuyong"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3-Java-%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">1.</span> <span class="toc-text">深入理解 Java 并发锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%94%81%E7%AE%80%E4%BB%8B"><span class="toc-number">1.1.</span> <span class="toc-text">并发锁简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-number">1.1.1.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81%E4%B8%8E%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.1.2.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81%E4%B8%8E%E5%85%B1%E4%BA%AB%E9%94%81"><span class="toc-number">1.1.3.</span> <span class="toc-text">独享锁与共享锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%82%B2%E8%A7%82%E9%94%81%E4%B8%8E%E4%B9%90%E8%A7%82%E9%94%81"><span class="toc-number">1.1.4.</span> <span class="toc-text">悲观锁与乐观锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E9%94%81%E3%80%81%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81%E3%80%81%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">1.1.5.</span> <span class="toc-text">偏向锁、轻量级锁、重量级锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E9%94%81"><span class="toc-number">1.1.6.</span> <span class="toc-text">分段锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E9%94%81%E5%92%8C%E5%86%85%E7%BD%AE%E9%94%81"><span class="toc-number">1.1.7.</span> <span class="toc-text">显示锁和内置锁</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lock-%E5%92%8C-Condition"><span class="toc-number">1.2.</span> <span class="toc-text">Lock 和 Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BD%95%E5%BC%95%E5%85%A5-Lock-%E5%92%8C-Condition"><span class="toc-number">1.2.1.</span> <span class="toc-text">为何引入 Lock 和 Condition</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Lock-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.2.2.</span> <span class="toc-text">Lock 接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Condition"><span class="toc-number">1.2.3.</span> <span class="toc-text">Condition</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">Condition 的特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Condition-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">Condition 的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantLock"><span class="toc-number">1.3.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">1.3.1.</span> <span class="toc-text">ReentrantLock 的特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E7%94%A8%E6%B3%95"><span class="toc-number">1.3.2.</span> <span class="toc-text">ReentrantLock 的用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">ReentrantLock 的构造方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lock-%E5%92%8C-unlock-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">lock 和 unlock 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#tryLock-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.3.</span> <span class="toc-text">tryLock 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lockInterruptibly-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.4.</span> <span class="toc-text">lockInterruptibly 方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#newCondition-%E6%96%B9%E6%B3%95"><span class="toc-number">1.3.2.5.</span> <span class="toc-text">newCondition 方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">ReentrantLock 的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ReentrantReadWriteLock"><span class="toc-number">1.4.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StampedLock"><span class="toc-number">1.5.</span> <span class="toc-text">StampedLock</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AQS"><span class="toc-number">1.6.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-%E7%9A%84%E8%A6%81%E7%82%B9"><span class="toc-number">1.6.1.</span> <span class="toc-text">AQS 的要点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">AQS 的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8B%AC%E4%BA%AB%E9%94%81-API"><span class="toc-number">1.6.2.1.</span> <span class="toc-text">独享锁 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E9%94%81-API"><span class="toc-number">1.6.2.2.</span> <span class="toc-text">共享锁 API</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">AQS 的原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E9%94%81"><span class="toc-number">1.7.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BB%E9%94%81"><span class="toc-number">1.8.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD"><span class="toc-number">1.9.</span> <span class="toc-text">未完待续</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#synchronized%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">1.9.1.</span> <span class="toc-text">synchronized解决方案</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%8A%E7%9A%84synchronized"><span class="toc-number">1.9.2.</span> <span class="toc-text">方法上的synchronized</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-number">1.9.3.</span> <span class="toc-text">变量的线程安全分析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Park-Unpark"><span class="toc-number">1.9.4.</span> <span class="toc-text">Park&amp;Unpark</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%BB%E9%94%81-1"><span class="toc-number">1.9.5.</span> <span class="toc-text">死锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B4%BB%E9%94%81-1"><span class="toc-number">1.9.6.</span> <span class="toc-text">活锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock-1"><span class="toc-number">1.9.7.</span> <span class="toc-text">ReentrantLock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-number">1.9.7.0.1.</span> <span class="toc-text">可重入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-number">1.9.7.0.2.</span> <span class="toc-text">可打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-number">1.9.7.0.3.</span> <span class="toc-text">锁超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-number">1.9.7.0.4.</span> <span class="toc-text">公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-number">1.9.7.0.5.</span> <span class="toc-text">条件变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98"><span class="toc-number">1.9.8.</span> <span class="toc-text">内存</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.9.8.1.</span> <span class="toc-text">内存模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%AF%E8%A7%81%E6%80%A7"><span class="toc-number">1.9.8.2.</span> <span class="toc-text">可见性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E6%80%A7"><span class="toc-number">1.9.8.3.</span> <span class="toc-text">有序性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#happens-before"><span class="toc-number">1.9.8.3.1.</span> <span class="toc-text">happens-before</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98"><span class="toc-number">1.9.9.</span> <span class="toc-text">不可变</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7"><span class="toc-number">1.9.10.</span> <span class="toc-text">工具</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">1.9.10.1.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ThreadPoolExecutor"><span class="toc-number">1.9.10.1.1.</span> <span class="toc-text">ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Fork-Join"><span class="toc-number">1.9.10.1.2.</span> <span class="toc-text">Fork&amp;Join</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#J-U-C"><span class="toc-number">1.9.10.2.</span> <span class="toc-text">J.U.C</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AQS-1"><span class="toc-number">1.9.10.2.1.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#AQS%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">1.9.10.2.1.1.</span> <span class="toc-text">AQS工作流程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#AQS%E4%BD%BF%E7%94%A8%E6%97%B6%E6%9C%BA"><span class="toc-number">1.9.10.2.1.2.</span> <span class="toc-text">AQS使用时机</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantLock%E5%8E%9F%E7%90%86"><span class="toc-number">1.9.10.2.2.</span> <span class="toc-text">ReentrantLock原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E9%94%81"><span class="toc-number">1.9.10.3.</span> <span class="toc-text">读写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#ReentrantReadWriteLock-1"><span class="toc-number">1.9.10.3.1.</span> <span class="toc-text">ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#StampedLock-1"><span class="toc-number">1.9.10.3.2.</span> <span class="toc-text">StampedLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Semaphore"><span class="toc-number">1.9.10.3.3.</span> <span class="toc-text">Semaphore</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CountdownLatch"><span class="toc-number">1.9.10.3.4.</span> <span class="toc-text">CountdownLatch</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CyclicBarrier"><span class="toc-number">1.9.10.3.5.</span> <span class="toc-text">CyclicBarrier</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%9B%86%E5%90%88%E7%B1%BB%E6%A6%82%E8%BF%B0"><span class="toc-number">1.9.10.3.6.</span> <span class="toc-text">线程安全集合类概述</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BlockingQueue"><span class="toc-number">1.9.10.3.7.</span> <span class="toc-text">BlockingQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ConcurrentLinkedQueue"><span class="toc-number">1.9.10.3.8.</span> <span class="toc-text">ConcurrentLinkedQueue</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#CopyOnWriteArrayList"><span class="toc-number">1.9.10.3.9.</span> <span class="toc-text">CopyOnWriteArrayList</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/c16f2ba9" title="ForkJoin框架"><img src="https://prod-alicdn-community.kurobbs.com/forum/7f933184dd4747a0bb326ff1bca1eda720250730.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ForkJoin框架"/></a><div class="content"><a class="title" href="/posts/c16f2ba9" title="ForkJoin框架">ForkJoin框架</a><time datetime="2025-10-18T07:27:46.000Z" title="发表于 2025-10-18 15:27:46">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/91e798bc" title="Java内存模型"><img src="https://prod-alicdn-community.kurobbs.com/forum/5803ca9faed74b0080a1156e0ef93aae20250529.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java内存模型"/></a><div class="content"><a class="title" href="/posts/91e798bc" title="Java内存模型">Java内存模型</a><time datetime="2025-10-18T02:43:11.000Z" title="发表于 2025-10-18 10:43:11">2025-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/19b32c42" title="Java并发工具类"><img src="https://prod-alicdn-community.kurobbs.com/forum/dcdad1b7aa454b97b412899068f94aa620250313.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Java并发工具类"/></a><div class="content"><a class="title" href="/posts/19b32c42" title="Java并发工具类">Java并发工具类</a><time datetime="2025-10-17T15:52:25.000Z" title="发表于 2025-10-17 23:52:25">2025-10-17</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By coder-xuyong</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div><div class="footer_custom_text">Hi, welcome to coder-xuyong's <a href="https://coder-xuyong.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><!-- butterfly右下角悬浮菜单栏 百分比--><span id="percent">0</span></button><!-- butterfly右下角悬浮菜单栏 直达底部--><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li4gzANXxmx9072g',
      clientSecret: 'b4da9f4490b2864bfdee5df73655329a642c6112',
      repo: 'coder-xuyong.github.io',
      owner: 'coder-xuyong',
      admin: ['coder-xuyong'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || 'fc0ee2df4b724bc791ebaeddc9cdaf72'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/self/custom.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="https://cn.vercount.one/js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search key word" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>