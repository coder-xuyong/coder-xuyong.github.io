<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Java查漏补缺 | coder-xuyong</title><meta name="author" content="coder-xuyong"><meta name="copyright" content="coder-xuyong"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="基础工具类String String 类能被继承吗？ String，StringBuffer，StringBuilder 的区别。  String 类不能被继承。因为其被 final 修饰，所以无法被继承。 StringBuffer，StringBuilder 拼接字符串，使用 append 比 String 效率高。因为 String 会隐式 new String 对象。 StringBuffe">
<meta property="og:type" content="article">
<meta property="og:title" content="Java查漏补缺">
<meta property="og:url" content="https://coder-xuyong.github.io/posts/ebd55e42">
<meta property="og:site_name" content="coder-xuyong">
<meta property="og:description" content="基础工具类String String 类能被继承吗？ String，StringBuffer，StringBuilder 的区别。  String 类不能被继承。因为其被 final 修饰，所以无法被继承。 StringBuffer，StringBuilder 拼接字符串，使用 append 比 String 效率高。因为 String 会隐式 new String 对象。 StringBuffe">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp">
<meta property="article:published_time" content="2025-06-22T05:51:00.000Z">
<meta property="article:modified_time" content="2025-11-27T06:52:00.689Z">
<meta property="article:author" content="coder-xuyong">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JavaSE">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Java查漏补缺",
  "url": "https://coder-xuyong.github.io/posts/ebd55e42",
  "image": "https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp",
  "datePublished": "2025-06-22T05:51:00.000Z",
  "dateModified": "2025-11-27T06:52:00.689Z",
  "author": [
    {
      "@type": "Person",
      "name": "coder-xuyong",
      "url": "https://coder-xuyong.github.io"
    }
  ]
}</script><link rel="shortcut icon" href="/medias/img/logo.png"><link rel="canonical" href="https://coder-xuyong.github.io/posts/ebd55e42"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          const mediaQueryDark = window.matchMedia('(prefers-color-scheme: dark)')
          const mediaQueryLight = window.matchMedia('(prefers-color-scheme: light)')

          if (theme === undefined) {
            if (mediaQueryLight.matches) activateLightMode()
            else if (mediaQueryDark.matches) activateDarkMode()
            else {
              const hour = new Date().getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            mediaQueryDark.addEventListener('change', () => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else {
            theme === 'light' ? activateLightMode() : activateDarkMode()
          }
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":false,"top_n_per_article":1,"unescape":false,"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300,"highlightFullpage":true,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":150,"languages":{"author":"作者: coder-xuyong","link":"链接: ","source":"来源: coder-xuyong","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyloadPlugin: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java查漏补缺',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/self/custom.css"><link rel="stylesheet" href="/self/progress_bar.css"><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><script>window.paceOptions = {
  restartOnPushState: false
}

btf.addGlobalFn('pjaxSend', () => {
  Pace.restart()
}, 'pace_restart')

</script><link rel="stylesheet" href="/self/progress_bar.css"/><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg" style="background-color: #fafafa;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/medias/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">100</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-bars-progress"></i><span> 合集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><img class="site-icon" src="/medias/img/logo.png" alt="Logo"><span class="site-name">coder-xuyong</span></a><a class="nav-page-title" href="/"><span class="site-name">Java查漏补缺</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa-solid fa-bars-progress"></i><span> 合集</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/java/"><i class="fa-fw fa-brands fa-java"></i><span> Java</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">Java查漏补缺<a class="post-edit-link" href="https://github.com/coder-xuyong/coder-xuyong.github.io/edit/main/source/_posts/01.Java/01.JavaSE/99.面试合集/99.Java面试.md" title="编辑" target="_blank"><i class="fas fa-pencil-alt"></i></a></h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-06-22T05:51:00.000Z" title="发表于 2025-06-22 13:51:00">2025-06-22</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-11-27T06:52:00.689Z" title="更新于 2025-11-27 14:52:00">2025-11-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/">1.Java</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/1-JavaSE/">1.JavaSE</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/1-Java/1-JavaSE/99-%E6%9F%A5%E6%BC%8F%E8%A1%A5%E7%BC%BA/">99.查漏补缺</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>45分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><div id="post-outdate-notice" data="{&quot;limitDay&quot;:365,&quot;messagePrev&quot;:&quot;已经过了&quot;,&quot;messageNext&quot;:&quot;天自上次更新，文章内容可能已过时。&quot;,&quot;postUpdate&quot;:&quot;2025-11-27 14:52:00&quot;}" hidden></div><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><blockquote>
<p>String 类能被继承吗？</p>
<p>String，StringBuffer，StringBuilder 的区别。</p>
</blockquote>
<p>String 类不能被继承。因为其被 final 修饰，所以无法被继承。</p>
<p>StringBuffer，StringBuilder 拼接字符串，使用 append 比 String 效率高。因为 String 会隐式 new String 对象。</p>
<p>StringBuffer 主要方法都用 synchronized 修饰，是线程安全的；而 StringBuilder 不是。</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><blockquote>
<p>抽象类和接口的区别？</p>
<p>类可以继承多个类么？接口可以继承多个接口么？类可以实现多个接口么？</p>
</blockquote>
<p>类只能继承一个类，但是可以实现多个接口。接口可以继承多个接口。</p>
<blockquote>
<p>继承和聚合的区别在哪？</p>
</blockquote>
<p>一般，能用聚合就别用继承。聚合是“has-a”，类似 school 类存在 teachers 的变量。</p>
<h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><h4 id="⭐-创建实例"><a href="#⭐-创建实例" class="headerlink" title="⭐ 创建实例"></a>⭐ 创建实例</h4><blockquote>
<p>反射创建实例有几种方式？</p>
</blockquote>
<p>通过反射来创建实例对象主要有两种方式：</p>
<ul>
<li>用 <code>Class</code> 对象的 <code>newInstance</code> 方法。</li>
<li>用 <code>Constructor</code> 对象的 <code>newInstance</code> 方法。</li>
</ul>
<h4 id="⭐-加载实例"><a href="#⭐-加载实例" class="headerlink" title="⭐ 加载实例"></a>⭐ 加载实例</h4><blockquote>
<p>加载实例有几种方式？</p>
<p>Class.forName(“className”) 和 ClassLoader.laodClass(“className”) 有什么区别？</p>
</blockquote>
<ul>
<li><code>Class.forName(&quot;className&quot;)</code> 加载的是已经初始化到 JVM 中的类。</li>
<li><code>ClassLoader.loadClass(&quot;className&quot;)</code> 装载的是还没有初始化到 JVM 中的类。</li>
</ul>
<h4 id="⭐⭐-动态代理"><a href="#⭐⭐-动态代理" class="headerlink" title="⭐⭐ 动态代理"></a>⭐⭐ 动态代理</h4><blockquote>
<p>动态代理有几种实现方式？有什么特点？</p>
<p>JDK 动态代理和 CGLIB 动态代理有什么区别？</p>
</blockquote>
<p>（1）JDK 方式</p>
<p>代理类与委托类实现同一接口，主要是通过代理类实现 <code>InvocationHandler</code> 并重写 <code>invoke</code> 方法来进行动态代理的，在 <code>invoke</code> 方法中将对方法进行处理。</p>
<p>JDK 动态代理特点：</p>
<ul>
<li>优点：相对于静态代理模式，不需要硬编码接口，代码复用率高。</li>
<li>缺点：强制要求代理类实现 <code>InvocationHandler</code> 接口。</li>
</ul>
<p>（2）CGLIB</p>
<p>CGLIB 底层，其实是借助了 ASM 这个强大的 Java 字节码框架去进行字节码增强操作。</p>
<p>CGLIB 动态代理特点：</p>
<p>优点：使用字节码增强，比 JDK 动态代理方式性能高。可以在运行时对类或者是接口进行增强操作，且委托类无需实现接口。</p>
<p>缺点：不能对 <code>final</code> 类以及 <code>final</code> 方法进行代理。</p>
<h3 id="JDK8"><a href="#JDK8" class="headerlink" title="JDK8"></a>JDK8</h3><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="⭐-hashcode"><a href="#⭐-hashcode" class="headerlink" title="⭐ hashcode"></a>⭐ hashcode</h4><blockquote>
<p>有<code>==</code>运算符了，为什么还需要 equals 啊？</p>
<p>说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需<br>要重新实现这两个方法。</p>
<p>有没有可能 2 个不相等的对象有相同的 hashcode</p>
</blockquote>
<p>（1）有<code>==</code>运算符了，为什么还需要 equals 啊？</p>
<p>equals 等价于<code>==</code>,而<code>==</code>运算符是判断两个对象是不是同一个对象，即他们的<strong>地址是否相等</strong>。而覆写 equals 更多的是追求两个对象在<strong>逻辑上的相等</strong>，你可以说是<strong>值相等</strong>，也可说是<strong>内容相等</strong>。</p>
<p>（2）说一说你对 java.lang.Object 对象中 hashCode 和 equals 方法的理解。在什么场景下需<br>要重新实现这两个方法。</p>
<p>在集合查找时，hashcode 能大大降低对象比较次数，提高查找效率！</p>
<p>（3）有没有可能 2 个不相等的对象有相同的 hashcode</p>
<p>有可能。</p>
<ul>
<li>如果两个对象 equals，Java 运行时环境会认为他们的 hashcode 一定相等。</li>
<li>如果两个对象不 equals，他们的 hashcode 有可能相等。</li>
<li>如果两个对象 hashcode 相等，他们不一定 equals。</li>
<li>如果两个对象 hashcode 不相等，他们一定不 equals。</li>
</ul>
<h2 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h2><h3 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h3><blockquote>
<p>什么是 NIO？</p>
<p>NIO 和 BIO、AIO 有何差别？</p>
</blockquote>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h4 id="⭐-序列化问题"><a href="#⭐-序列化问题" class="headerlink" title="⭐ 序列化问题"></a>⭐ 序列化问题</h4><blockquote>
<p>序列化、反序列化有哪些问题？如何解决？</p>
</blockquote>
<p>Java 的序列化能保证对象状态的持久保存，但是遇到一些对象结构复杂的情况还是难以处理，这里归纳一下：</p>
<ul>
<li>当父类继承 <code>Serializable</code> 接口时，所有子类都可以被序列化。</li>
<li>子类实现了 <code>Serializable</code> 接口，父类没有，则父类的属性不会被序列化（不报错，数据丢失），子类的属性仍可以正确序列化。</li>
<li>如果序列化的属性是对象，则这个对象也必须实现 <code>Serializable</code> 接口，否则会报错。</li>
<li>在反序列化时，如果对象的属性有修改或删减，则修改的部分属性会丢失，但不会报错。</li>
<li>在反序列化时，如果 <code>serialVersionUID</code> 被修改，则反序列化时会失败。</li>
</ul>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList-和-LinkedList-有什么区别？"><a href="#ArrayList-和-LinkedList-有什么区别？" class="headerlink" title="ArrayList 和 LinkedList 有什么区别？"></a>ArrayList 和 LinkedList 有什么区别？</h4><p>ArrayList 是数组链表，访问效率更高。</p>
<p>LinkedList 是双链表，数据有序存储。</p>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>请描述 HashMap 的实现原理？</p>
<p>hashmap 数组和链表多少长度时候，会转化为红黑树?</p>
<a href="/posts/9dd42db4.html#Set" title="java 高级">🚀 HashMap底层</a>
<h2 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h2><h3 id="并发简介"><a href="#并发简介" class="headerlink" title="并发简介"></a>并发简介</h3><h4 id="什么是进程？什么是线程？进程和线程的区别？"><a href="#什么是进程？什么是线程？进程和线程的区别？" class="headerlink" title="什么是进程？什么是线程？进程和线程的区别？"></a>什么是进程？什么是线程？进程和线程的区别？</h4><ul>
<li>什么是进程？<ul>
<li>简言之，进程可视为一个正在运行的程序。</li>
<li>进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。</li>
</ul>
</li>
<li>什么是线程？<ul>
<li>线程是操作系统进行调度的基本单位。</li>
</ul>
</li>
<li>进程 vs. 线程<ul>
<li>一个程序至少有一个进程，一个进程至少有一个线程。</li>
<li>线程比进程划分更细，所以执行开销更小，并发性更高。</li>
<li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li>
</ul>
</li>
</ul>
<h4 id="并发（多线程）编程的好处是什么？"><a href="#并发（多线程）编程的好处是什么？" class="headerlink" title="并发（多线程）编程的好处是什么？"></a>并发（多线程）编程的好处是什么？</h4><ul>
<li>更有效率的利用多处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
<h4 id="并发一定比串行更快吗？"><a href="#并发一定比串行更快吗？" class="headerlink" title="并发一定比串行更快吗？"></a>并发一定比串行更快吗？</h4><p>答：否。</p>
<p>要点：<strong>创建线程和线程上下文切换有一定开销</strong>。</p>
<p>说明：即使是单核处理器也支持多线程。CPU 通过给每个线程分配时间切片的算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保持上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>引申</p>
<ul>
<li>如何减少上下文切换？<ul>
<li>尽量少用锁</li>
<li>CAS 算法</li>
<li>线程数要合理</li>
<li>协程：在单线程中实现多任务调度，并在单线程中维持多个任务的切换</li>
</ul>
</li>
</ul>
<h4 id="如何让正在运行的线程暂停一段时间？"><a href="#如何让正在运行的线程暂停一段时间？" class="headerlink" title="如何让正在运行的线程暂停一段时间？"></a>如何让正在运行的线程暂停一段时间？</h4><p>我们可以使用 <code>Thread</code> 类的 Sleep() 方法让线程暂停一段时间。</p>
<p>需要注意的是，这并不会让线程终止，一旦从休眠中唤醒线程，线程的状态将会被改变为 Runnable，并且根据线程调度，它将得到执行。</p>
<h4 id="什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？"><a href="#什么是线程调度器-Thread-Scheduler-和时间分片-Time-Slicing-？" class="headerlink" title="什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？"></a>什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</h4><p>线程调度器是一个操作系统服务，它负责为 <code>Runnable</code> 状态的线程分配 CPU 时间。一旦我们创建一个线程并启动它，它的执行便依赖于线程调度器的实现。</p>
<p>时间分片是指将可用的 CPU 时间分配给可用的 <code>Runnable</code> 线程的过程。</p>
<p>分配 CPU 时间可以基于线程优先级或者线程等待的时间。线程调度并不受到 Java 虚拟机控制，所以由应用程序来控制它是更好的选择（也就是说不要让你的程序依赖于线程的优先级）。</p>
<h4 id="在多线程中，什么是上下文切换-context-switching-？"><a href="#在多线程中，什么是上下文切换-context-switching-？" class="headerlink" title="在多线程中，什么是上下文切换(context-switching)？"></a>在多线程中，什么是上下文切换(context-switching)？</h4><p>上下文切换是存储和恢复 CPU 状态的过程，它使得线程执行能够从中断点恢复执行。上下文切换是多任务操作系统和多线程环境的基本特征。</p>
<h4 id="如何确保线程安全？"><a href="#如何确保线程安全？" class="headerlink" title="如何确保线程安全？"></a>如何确保线程安全？</h4><ul>
<li>原子类(atomic concurrent classes)</li>
<li>锁</li>
<li><code>volatile</code> 关键字</li>
<li>不变类和线程安全类</li>
</ul>
<h4 id="什么是死锁-Deadlock-？如何分析和避免死锁？"><a href="#什么是死锁-Deadlock-？如何分析和避免死锁？" class="headerlink" title="什么是死锁(Deadlock)？如何分析和避免死锁？"></a>什么是死锁(Deadlock)？如何分析和避免死锁？</h4><p>死锁是指两个以上的线程永远相互阻塞的情况，这种情况产生至少需要两个以上的线程和两个以上的资源。</p>
<p>分析死锁，我们需要查看 Java 应用程序的线程转储。我们需要找出那些状态为 BLOCKED 的线程和他们等待的资源。每个资源都有一个唯一的 id，用这个 id 我们可以找出哪些线程已经拥有了它的对象锁。</p>
<p>避免嵌套锁，只在需要的地方使用锁和避免无限期等待是避免死锁的通常办法。</p>
<h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><h4 id="Java-线程生命周期中有哪些状态？各状态之间如何切换？"><a href="#Java-线程生命周期中有哪些状态？各状态之间如何切换？" class="headerlink" title="Java 线程生命周期中有哪些状态？各状态之间如何切换？"></a>Java 线程生命周期中有哪些状态？各状态之间如何切换？</h4><p><img src="https://raw.githubusercontent.com/coder-xuyong/coder-xuyong/main/img/blog/java/java-thread_1.png" alt="img"></p>
<p><code>java.lang.Thread.State</code> 中定义了 <strong>6</strong> 种不同的线程状态，在给定的一个时刻，线程只能处于其中的一个状态。</p>
<p>以下是各状态的说明，以及状态间的联系：</p>
<ul>
<li><strong>开始（New）</strong> - 还没有调用 <code>start()</code> 方法的线程处于此状态。</li>
<li><strong>可运行（Runnable）</strong> - 已经调用了 <code>start()</code> 方法的线程状态。此状态意味着，线程已经准备好了，一旦被线程调度器分配了 CPU 时间片，就可以运行线程。</li>
<li><strong>阻塞（Blocked）</strong> - 阻塞状态。线程阻塞的线程状态等待监视器锁定。处于阻塞状态的线程正在等待监视器锁定，以便在调用 <code>Object.wait()</code> 之后输入同步块&#x2F;方法或重新输入同步块&#x2F;方法。</li>
<li><strong>等待（Waiting）</strong> - 等待状态。一个线程处于等待状态，是由于执行了 3 个方法中的任意方法：<ul>
<li><code>Object.wait()</code></li>
<li><code>Thread.join()</code></li>
<li><code>LockSupport.park()</code></li>
</ul>
</li>
<li><strong>定时等待（Timed waiting）</strong> - 等待指定时间的状态。一个线程处于定时等待状态，是由于执行了以下方法中的任意方法：<ul>
<li><code>Thread.sleep(sleeptime)</code></li>
<li><code>Object.wait(timeout)</code></li>
<li><code>Thread.join(timeout)</code></li>
<li><code>LockSupport.parkNanos(timeout)</code></li>
<li><code>LockSupport.parkUntil(timeout)</code></li>
</ul>
</li>
<li><strong>终止(Terminated)</strong> - 线程 <code>run()</code> 方法执行结束，或者因异常退出了 <code>run()</code> 方法，则该线程结束生命周期。死亡的线程不可再次复生。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://www.w3resource.com/java-tutorial/java-threadclass-methods-and-threadstates.php">Java<code>Thread</code> Methods and <code>Thread</code> States</a><br>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/pange1991/article/details/53860651">Java 线程的 5 种状态及切换(透彻讲解)</a></p>
</blockquote>
<h4 id="创建线程有哪些方式？这些方法各自利弊是什么？"><a href="#创建线程有哪些方式？这些方法各自利弊是什么？" class="headerlink" title="创建线程有哪些方式？这些方法各自利弊是什么？"></a>创建线程有哪些方式？这些方法各自利弊是什么？</h4><p>创建线程主要有三种方式：</p>
<p><strong>1. 继承 <code>Thread</code> 类</strong></p>
<ul>
<li>定义 <code>Thread</code> 类的子类，并重写该类的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体就代表了线程要完成的任务。因此把 <code>run()</code> 方法称为执行体。</li>
<li>创建 <code>Thread</code> 子类的实例，即创建了线程对象。</li>
<li>调用线程对象的 <code>start()</code> 方法来启动该线程。</li>
</ul>
<p><strong>2. 实现 <code>Runnable</code> 接口</strong></p>
<ul>
<li>定义 <code>Runnable</code> 接口的实现类，并重写该接口的 <code>run()</code> 方法，该 <code>run()</code> 方法的方法体同样是该线程的线程执行体。</li>
<li>创建 <code>Runnable</code> 实现类的实例，并以此实例作为 <code>Thread</code> 对象，该 <code>Thread</code> 对象才是真正的线程对象。</li>
<li>调用线程对象的 start() 方法来启动该线程。</li>
</ul>
<p><strong>3. 通过 <code>Callable</code> 接口和 <code>Future</code> 接口</strong></p>
<ul>
<li>创建 <code>Callable</code> 接口的实现类，并实现 <code>call()</code> 方法，该 <code>call()</code> 方法将作为线程执行体，并且有返回值。</li>
<li>创建 <code>Callable</code> 实现类的实例，使用 <code>FutureTask</code> 类来包装 <code>Callable</code> 对象，该 <code>FutureTask</code> 对象封装了该 <code>Callable</code> 对象的 <code>call()</code> 方法的返回值。</li>
<li>使用 <code>FutureTask</code> 对象作为 <code>Thread</code> 对象的 target 创建并启动新线程。</li>
<li>调用 <code>FutureTask</code> 对象的 <code>get()</code> 方法来获得子线程执行结束后的返回值</li>
</ul>
<p>三种创建线程方式对比</p>
<ul>
<li>实现 <code>Runnable</code> 接口优于继承 <code>Thread</code> 类，因为根据开放封闭原则——实现接口更便于扩展；</li>
<li>实现 <code>Runnable</code> 接口的线程没有返回值；而使用 <code>Callable</code> &#x2F; <code>Future</code> 方式可以让线程有返回值。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/longshengguoji/article/details/41126119">Java 创建线程的三种方式及其对比</a></p>
</blockquote>
<h4 id="什么是-Callable-和-Future？什么是-FutureTask？"><a href="#什么是-Callable-和-Future？什么是-FutureTask？" class="headerlink" title="什么是 Callable 和 Future？什么是 FutureTask？"></a>什么是 <code>Callable</code> 和 <code>Future</code>？什么是 <code>FutureTask</code>？</h4><p><strong>什么是 <code>Callable</code> 和 <code>Future</code>？</strong></p>
<p>Java 5 在 concurrency 包中引入了 <code>Callable</code> 接口，它和 <code>Runnable</code> 接口很相似，但它可以返回一个对象或者抛出一个异常。</p>
<p><code>Callable</code> 接口使用泛型去定义它的返回类型。<code>Executors</code> 类提供了一些有用的方法去在线程池中执行 <code>Callable</code> 内的任务。由于 <code>Callable</code> 任务是并行的，我们必须等待它返回的结果。<code>Future</code> 对象为我们解决了这个问题。在线程池提交 <code>Callable</code> 任务后返回了一个 <code>Future</code> 对象，使用它我们可以知道 <code>Callable</code> 任务的状态和得到 <code>Callable</code> 返回的执行结果。<code>Future</code> 提供了 <code>get()</code> 方法让我们可以等待 <code>Callable</code> 结束并获取它的执行结果。</p>
<p><strong>什么是 <code>FutureTask</code>？</strong></p>
<p><code>FutureTask</code> 是 <code>Future</code> 的一个基础实现，我们可以将它同 <code>Executors</code> 使用处理异步任务。通常我们不需要使用 <code>FutureTask</code> 类，单当我们打算重写 <code>Future</code> 接口的一些方法并保持原来基础的实现是，它就变得非常有用。我们可以仅仅继承于它并重写我们需要的方法。阅读 Java <code>FutureTask</code> 例子，学习如何使用它。</p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3949310.html">Java 并发编程：Callable、Future 和 FutureTask</a></p>
</blockquote>
<h4 id="start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？"><a href="#start-和-run-有什么区别？可以直接调用-Thread-类的-run-方法么？" class="headerlink" title="start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？"></a><code>start()</code> 和 <code>run()</code> 有什么区别？可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</h4><ul>
<li><code>run()</code> 方法是线程的执行体。</li>
<li><code>start()</code> 方法负责启动线程，然后 JVM 会让这个线程去执行 <code>run()</code> 方法。</li>
</ul>
<p>可以直接调用 <code>Thread</code> 类的 <code>run()</code> 方法么？</p>
<ul>
<li>可以。但是如果直接调用 <code>Thread</code> 的 <code>run()</code> 方法，它的行为就会和普通的方法一样。</li>
<li>为了在新的线程中执行我们的代码，必须使用 <code>start()</code> 方法。</li>
</ul>
<h4 id="sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？"><a href="#sleep-、yield-、join-方法有什么区别？为什么-sleep-和-yield-方法是静态（static）的？" class="headerlink" title="sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？"></a><code>sleep()</code>、<code>yield()</code>、<code>join()</code> 方法有什么区别？为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</h4><p><strong><code>yield()</code></strong></p>
<ul>
<li><code>yield()</code> 方法可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程从 <strong>Running</strong> 状态转入 <code>Runnable</code> 状态。</li>
<li>当某个线程调用了 <code>yield()</code> 方法暂停之后，只有优先级与当前线程相同，或者优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。</li>
</ul>
<p><strong><code>sleep()</code></strong></p>
<ul>
<li><code>sleep()</code> 方法需要指定等待的时间，它可以让当前正在执行的线程在指定的时间内暂停执行，进入 <strong>Blocked</strong> 状态。</li>
<li>该方法既可以让其他同优先级或者高优先级的线程得到执行的机会，也可以让低优先级的线程得到执行机会。</li>
<li>但是，<code>sleep()</code> 方法不会释放“锁标志”，也就是说如果有 <code>synchronized</code> 同步块，其他线程仍然不能访问共享数据。</li>
</ul>
<p><strong><code>join()</code></strong></p>
<ul>
<li><code>join()</code> 方法会使当前线程转入 <strong>Blocked</strong> 状态，等待调用 <code>join()</code> 方法的线程结束后才能继续执行。</li>
</ul>
<p><strong>为什么 <code>sleep()</code> 和 <code>yield()</code> 方法是静态（static）的？</strong></p>
<ul>
<li><code>Thread</code> 类的 <code>sleep()</code> 和 <code>yield()</code> 方法将处理 <strong>Running</strong> 状态的线程。所以在其他处于非 <strong>Running</strong> 状态的线程上执行这两个方法是没有意义的。这就是为什么这些方法是静态的。它们可以在当前正在执行的线程中工作，并避免程序员错误的认为可以在其他非运行线程调用这些方法。</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.importnew.com/14958.html">Java 线程中 yield 与 join 方法的区别</a><br>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/xiangwanpeng/article/details/54972952">sleep()，wait()，yield()和 join()方法的区别</a></p>
</blockquote>
<h4 id="Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？"><a href="#Java-的线程优先级如何控制？高优先级的-Java-线程一定先执行吗？" class="headerlink" title="Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？"></a>Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</h4><p><strong>Java 中的线程优先级如何控制</strong></p>
<ul>
<li>Java 中的线程优先级的范围是 <code>[1,10]</code>，一般来说，高优先级的线程在运行时会具有优先权。可以通过 <code>thread.setPriority(Thread.MAX_PRIORITY)</code> 的方式设置，默认优先级为 <code>5</code>。</li>
</ul>
<p><strong>高优先级的 Java 线程一定先执行吗</strong></p>
<ul>
<li>即使设置了线程的优先级，也<strong>无法保证高优先级的线程一定先执行</strong>。</li>
<li>原因：这是因为 <strong>Java 线程优先级依赖于操作系统的支持</strong>，然而，不同的操作系统支持的线程优先级并不相同，不能很好的和 Java 中线程优先级一一对应。</li>
<li>结论：Java 线程优先级控制并不可靠。</li>
</ul>
<h4 id="什么是守护线程？为什么要用守护线程？如何创建守护线程？"><a href="#什么是守护线程？为什么要用守护线程？如何创建守护线程？" class="headerlink" title="什么是守护线程？为什么要用守护线程？如何创建守护线程？"></a>什么是守护线程？为什么要用守护线程？如何创建守护线程？</h4><p><strong>什么是守护线程</strong></p>
<ul>
<li>守护线程（Daemon Thread）是在后台执行并且不会阻止 JVM 终止的线程。</li>
<li>与守护线程（Daemon Thread）相反的，叫用户线程（User Thread），也就是非守护线程。</li>
</ul>
<p><strong>为什么要用守护线程</strong></p>
<ul>
<li>守护线程的优先级比较低，用于为系统中的其它对象和线程提供服务。典型的应用就是垃圾回收器。</li>
</ul>
<p><strong>如何创建守护线程</strong></p>
<ul>
<li>使用 <code>thread.setDaemon(true)</code> 可以设置 thread 线程为守护线程。</li>
<li>注意点：<ul>
<li>正在运行的用户线程无法设置为守护线程，所以 <code>thread.setDaemon(true)</code> 必须在 <code>thread.start()</code> 之前设置，否则会抛出 <code>llegalThreadStateException</code> 异常；</li>
<li>一个守护线程创建的子线程依然是守护线程。</li>
<li>不要认为所有的应用都可以分配给守护线程来进行服务，比如读写操作或者计算逻辑。</li>
</ul>
</li>
</ul>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/shimiso/article/details/8964414">Java 中守护线程的总结</a></p>
</blockquote>
<h4 id="线程间是如何通信的？"><a href="#线程间是如何通信的？" class="headerlink" title="线程间是如何通信的？"></a>线程间是如何通信的？</h4><p>当线程间是可以共享资源时，线程间通信是协调它们的重要的手段。<code>Object</code> 类中 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 方法可以用于线程间通信关于资源的锁的状态。</p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="http://www.cnblogs.com/dolphin0520/p/3920385.html">Java 并发编程：线程间协作的两种方式：wait、notify、notifyAll 和 Condition</a></p>
</blockquote>
<h4 id="为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？"><a href="#为什么线程通信的方法-wait-notify-和-notifyAll-被定义在-Object-类里？" class="headerlink" title="为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？"></a>为什么线程通信的方法 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 被定义在 Object 类里？</h4><p>Java 的每个对象中都有一个锁(monitor，也可以成为监视器) 并且 <code>wait()</code>、<code>notify()</code> 等方法用于等待对象的锁或者通知其他线程对象的监视器可用。在 Java 的线程中并没有可供任何对象使用的锁和同步器。这就是为什么这些方法是 Object 类的一部分，这样 Java 的每一个类都有用于线程间通信的基本方法</p>
<h4 id="为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？"><a href="#为什么-wait-notify-和-notifyAll-必须在同步方法或者同步块中被调用？" class="headerlink" title="为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？"></a>为什么 <code>wait()</code>, <code>notify()</code> 和 <code>notifyAll()</code> 必须在同步方法或者同步块中被调用？</h4><p>当一个线程需要调用对象的 <code>wait()</code> 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 <code>notify()</code> 方法。同样的，当一个线程需要调用对象的 <code>notify()</code> 方法时，它会释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。</p>
<p>由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。</p>
<h3 id="并发机制的底层实现"><a href="#并发机制的底层实现" class="headerlink" title="并发机制的底层实现"></a>并发机制的底层实现</h3><blockquote>
<p>👉 参考阅读：<a href="/posts/b9e487ed" title="Java并发核心机制">🚀 java 并发核心机制</a></p>
</blockquote>
<h4 id="⭐⭐⭐-synchronized"><a href="#⭐⭐⭐-synchronized" class="headerlink" title="⭐⭐⭐ synchronized"></a>⭐⭐⭐ <code>synchronized</code></h4><blockquote>
<p><code>synchronized</code> 有什么作用？</p>
<p><code>synchronized</code> 的原理是什么？</p>
<p>同步方法和同步块，哪个更好？</p>
<p>JDK1.6 对<code>synchronized</code> 做了哪些优化？</p>
<p>使用 <code>synchronized</code> 修饰静态方法和非静态方法有什么区别？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p>
<p><code>synchronized</code> 有 3 种应用方式：</p>
<ul>
<li><strong>同步实例方法</strong> - 对于普通同步方法，锁是当前实例对象</li>
<li><strong>同步静态方法</strong> - 对于静态同步方法，锁是当前类的 <code>Class</code> 对象</li>
<li><strong>同步代码块</strong> - 对于同步方法块，锁是 <code>synchonized</code> 括号里配置的对象</li>
</ul>
<p><strong>原理</strong></p>
<p><code>synchronized</code> 经过编译后，会在同步块的前后分别形成 <code>monitorenter</code> 和 <code>monitorexit</code> 这两个字节码指令，这两个字节码指令都需要一个引用类型的参数来指明要锁定和解锁的对象。如果 <code>synchronized</code> 明确制定了对象参数，那就是这个对象的引用；如果没有明确指定，那就根据 <code>synchronized</code> 修饰的是实例方法还是静态方法，去对对应的对象实例或 <code>Class</code> 对象来作为锁对象。</p>
<p><code>synchronized</code> 同步块对同一线程来说是可重入的，不会出现锁死问题。</p>
<p><code>synchronized</code> 同步块是互斥的，即已进入的线程执行完成前，会阻塞其他试图进入的线程。</p>
<p><strong>优化</strong></p>
<p>Java 1.6 以后，<code>synchronized</code> 做了大量的优化，其性能已经与 <code>Lock</code> 、<code>ReadWriteLock</code> 基本上持平。</p>
<p><code>synchronized</code> 的优化是将锁粒度分为不同级别，<code>synchronized</code> 会根据运行状态动态的由低到高调整锁级别（<strong>偏向锁</strong> -&gt; <strong>轻量级锁</strong> -&gt; <strong>重量级锁</strong>），以减少阻塞。</p>
<p><strong>同步方法 or 同步块？</strong></p>
<ul>
<li>同步块是更好的选择。</li>
<li>因为它不会锁住整个对象（当然你也可以让它锁住整个对象）。同步方法会锁住整个对象，哪怕这个类中有多个不相关联的同步块，这通常会导致他们停止执行并需要等待获得这个对象上的锁。</li>
</ul>
<h4 id="⭐-volatile"><a href="#⭐-volatile" class="headerlink" title="⭐ volatile"></a>⭐ <code>volatile</code></h4><blockquote>
<p><code>volatile</code> 有什么作用？</p>
<p><code>volatile</code> 的原理是什么？</p>
<p><code>volatile</code> 能代替锁吗？</p>
<p><code>volatile</code> 和 <code>synchronized</code> 的区别？</p>
</blockquote>
<p><strong><code>volatile</code> 无法替代 <code>synchronized</code> ，因为 <code>volatile</code> 无法保证操作的原子性</strong>。</p>
<p><strong>作用</strong></p>
<p>被 <code>volatile</code> 关键字修饰的变量有两层含义：</p>
<ul>
<li><strong>保证了不同线程对这个变量进行操作时的可见性</strong>，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。</li>
<li><strong>禁止指令重排序</strong>。</li>
</ul>
<p><strong>原理</strong></p>
<p>观察加入 volatile 关键字和没有加入 volatile 关键字时所生成的汇编代码发现，<strong>加入 <code>volatile</code> 关键字时，会多出一个 <code>lock</code> 前缀指令</strong>。</p>
<p><strong><code>lock</code> 前缀指令实际上相当于一个内存屏障</strong>（也成内存栅栏），内存屏障会提供 3 个功能：</p>
<ul>
<li>它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；</li>
<li>它会强制将对缓存的修改操作立即写入主存；</li>
<li>如果是写操作，它会导致其他 CPU 中对应的缓存行无效。</li>
</ul>
<p><strong><code>volatile</code> 和 <code>synchronized</code> 的区别？</strong></p>
<ul>
<li><code>volatile</code> 本质是在告诉 jvm 当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取； <code>synchronized</code> 则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。</li>
<li><code>volatile</code> 仅能使用在变量级别；synchronized 则可以使用在变量、方法、和类级别的。</li>
<li><code>volatile</code> 仅能实现变量的修改可见性，不能保证原子性；而 <code>synchronized</code> 则可以保证变量的修改可见性和原子性</li>
<li><code>volatile</code> 不会造成线程的阻塞；synchronized 可能会造成线程的阻塞。</li>
<li><code>volatile</code> 标记的变量不会被编译器优化；synchronized 标记的变量可以被编译器优化。</li>
</ul>
<h4 id="⭐⭐-CAS"><a href="#⭐⭐-CAS" class="headerlink" title="⭐⭐ CAS"></a>⭐⭐ CAS</h4><blockquote>
<p>什么是 CAS？</p>
<p>CAS 有什么作用？</p>
<p>CAS 的原理是什么？</p>
<p>CAS 的三大问题？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong>CAS（Compare and Swap）</strong>，字面意思为<strong>比较并交换</strong>。CAS 有 3 个操作数，分别是：内存值 V，旧的预期值 A，要修改的新值 B。当且仅当旧预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。</p>
<p><strong>原理</strong></p>
<p>Java 主要利用 <code>Unsafe</code> 这个类提供的 CAS 操作。<code>Unsafe</code> 的 CAS 依赖的是 JV M 针对不同的操作系统实现的 <code>Atomic::cmpxchg</code> 指令。</p>
<p><strong>三大问题</strong></p>
<ol>
<li><strong>ABA 问题</strong>：因为 CAS 需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值原来是 A，变成了 B，又变成了 A，那么使用 CAS 进行检查时会发现它的值没有发生变化，但是实际上却变化了。ABA 问题的解决思路就是使用版本号。在变量前面追加上版本号，每次变量更新的时候把版本号加一，那么 A－B－A 就会变成 1A-2B－3A。</li>
<li><strong>循环时间长开销大</strong>。自旋 CAS 如果长时间不成功，会给 CPU 带来非常大的执行开销。如果 JVM 能支持处理器提供的 pause 指令那么效率会有一定的提升，pause 指令有两个作用，第一它可以延迟流水线执行指令（de-pipeline）,使 CPU 不会消耗过多的执行资源，延迟的时间取决于具体实现的版本，在一些处理器上延迟时间是零。第二它可以避免在退出循环的时候因内存顺序冲突（memory order violation）而引起 CPU 流水线被清空（CPU pipeline flush），从而提高 CPU 的执行效率。</li>
<li><strong>只能保证一个共享变量的原子操作</strong>。当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁，或者有一个取巧的办法，就是把多个共享变量合并成一个共享变量来操作。比如有两个共享变量 i ＝ 2,j&#x3D;a，合并一下 ij&#x3D;2a，然后用 CAS 来操作 ij。从 Java1.5 开始 JDK 提供了 AtomicReference 类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</li>
</ol>
<h4 id="⭐-ThreadLocal"><a href="#⭐-ThreadLocal" class="headerlink" title="⭐ ThreadLocal"></a>⭐ <code>ThreadLocal</code></h4><blockquote>
<p><code>ThreadLocal</code> 有什么作用？</p>
<p><code>ThreadLocal</code> 的原理是什么？</p>
<p>如何解决 <code>ThreadLocal</code> 内存泄漏问题？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>ThreadLocal</code> 是一个存储线程本地副本的工具类</strong>。</p>
<p><strong>原理</strong></p>
<p><code>Thread</code> 类中维护着一个 <code>ThreadLocal.ThreadLocalMap</code> 类型的成员 <code>threadLocals</code>。这个成员就是用来存储当前线程独占的变量副本。</p>
<p><code>ThreadLocalMap</code> 是 <code>ThreadLocal</code> 的内部类，它维护着一个 <code>Entry</code> 数组， <code>Entry</code> 用于保存键值对，其 key 是 <code>ThreadLocal</code> 对象，value 是传递进来的对象（变量副本）。 <code>Entry</code> 继承了 <code>WeakReference</code> ，所以是弱引用。</p>
<p><strong>内存泄漏问题</strong></p>
<p>ThreadLocalMap 的 <code>Entry</code> 继承了 <code>WeakReference</code>，所以它的 key （<code>ThreadLocal</code> 对象）是弱引用，而 value （变量副本）是强引用。</p>
<ul>
<li>如果 <code>ThreadLocal</code> 对象没有外部强引用来引用它，那么 <code>ThreadLocal</code> 对象会在下次 GC 时被回收。</li>
<li>此时，<code>Entry</code> 中的 key 已经被回收，但是 value 由于是强引用不会被垃圾收集器回收。如果创建 <code>ThreadLocal</code> 的线程一直持续运行，那么 value 就会一直得不到回收，产生内存泄露。</li>
</ul>
<p>那么如何避免内存泄漏呢？方法就是：<strong>使用 <code>ThreadLocal</code> 的 <code>set</code> 方法后，显示的调用 <code>remove</code> 方法</strong> 。</p>
<h3 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h3><h4 id="什么是-Java-内存模型"><a href="#什么是-Java-内存模型" class="headerlink" title="什么是 Java 内存模型"></a>什么是 Java 内存模型</h4><ul>
<li>Java 内存模型即 Java Memory Model，简称 JMM。JMM 定义了 JVM 在计算机内存(RAM)中的工作方式。JMM 是隶属于 JVM 的。</li>
<li>并发编程领域两个关键问题：线程间通信和线程间同步</li>
<li>线程间通信机制<ul>
<li>共享内存 - 线程间通过写-读内存中的公共状态来隐式进行通信。</li>
<li>消息传递 - java 中典型的消息传递方式就是 wait()和 notify()。</li>
</ul>
</li>
<li>线程间同步机制<ul>
<li>在共享内存模型中，必须显示指定某个方法或某段代码在线程间互斥地执行。</li>
<li>在消息传递模型中，由于发送消息必须在接收消息之前，因此同步是隐式进行的。</li>
</ul>
</li>
<li>Java 的并发采用的是共享内存模型</li>
<li>JMM 决定一个线程对共享变量的写入何时对另一个线程可见。</li>
<li>线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读&#x2F;写共享变量的副本。</li>
<li>JMM 把内存分成了两部分：线程栈区和堆区<ul>
<li>线程栈<ul>
<li>JVM 中运行的每个线程都拥有自己的线程栈，线程栈包含了当前线程执行的方法调用相关信息，我们也把它称作调用栈。随着代码的不断执行，调用栈会不断变化。</li>
<li>线程栈还包含了当前方法的所有本地变量信息。线程中的本地变量对其它线程是不可见的。</li>
</ul>
</li>
<li>堆区<ul>
<li>堆区包含了 Java 应用创建的所有对象信息，不管对象是哪个线程创建的，其中的对象包括原始类型的封装类（如 Byte、Integer、Long 等等）。不管对象是属于一个成员变量还是方法中的本地变量，它都会被存储在堆区。</li>
</ul>
</li>
<li>一个本地变量如果是原始类型，那么它会被完全存储到栈区。</li>
<li>一个本地变量也有可能是一个对象的引用，这种情况下，这个本地引用会被存储到栈中，但是对象本身仍然存储在堆区。</li>
<li>对于一个对象的成员方法，这些方法中包含本地变量，仍需要存储在栈区，即使它们所属的对象在堆区。</li>
<li>对于一个对象的成员变量，不管它是原始类型还是包装类型，都会被存储到堆区。</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/java-memory-model_3.png" alt="img"></p>
<blockquote>
<p>👉 参考阅读：<a target="_blank" rel="noopener" href="https://blog.csdn.net/suifeng3051/article/details/52611310">全面理解 Java 内存模型</a></p>
</blockquote>
<h3 id="同步容器和并发容器"><a href="#同步容器和并发容器" class="headerlink" title="同步容器和并发容器"></a>同步容器和并发容器</h3><blockquote>
<p>👉 参考阅读：<a href="/posts/7ea96e03" title="Java并发和容器">🚀 java 并发容器</a></p>
</blockquote>
<h4 id="⭐-同步容器"><a href="#⭐-同步容器" class="headerlink" title="⭐ 同步容器"></a>⭐ 同步容器</h4><blockquote>
<p>什么是同步容器？</p>
<p>有哪些常见同步容器？</p>
<p>它们是如何实现线程安全的？</p>
<p>同步容器真的线程安全吗？</p>
</blockquote>
<p><strong>类型</strong></p>
<p><code>Vector</code>、<code>Stack</code>、<code>Hashtable</code></p>
<p><strong>作用&#x2F;原理</strong></p>
<p>同步容器的同步原理就是在方法上用 <code>synchronized</code> 修饰。 <strong><code>synchronized</code> 可以保证在同一个时刻，只有一个线程可以执行某个方法或者某个代码块</strong>。</p>
<p><code>synchronized</code> 的互斥同步会产生阻塞和唤醒线程的开销。显然，这种方式比没有使用 <code>synchronized</code> 的容器性能要差。</p>
<p><strong>线程安全</strong></p>
<p>同步容器真的绝对安全吗？</p>
<p>其实也未必。在做复合操作（非原子操作）时，仍然需要加锁来保护。常见复合操作如下：</p>
<ul>
<li><strong>迭代</strong>：反复访问元素，直到遍历完全部元素；</li>
<li><strong>跳转</strong>：根据指定顺序寻找当前元素的下一个（下 n 个）元素；</li>
<li><strong>条件运算</strong>：例如若没有则添加等；</li>
</ul>
<h4 id="⭐⭐⭐-ConcurrentHashMap"><a href="#⭐⭐⭐-ConcurrentHashMap" class="headerlink" title="⭐⭐⭐ ConcurrentHashMap"></a>⭐⭐⭐ ConcurrentHashMap</h4><blockquote>
<p>请描述 ConcurrentHashMap 的实现原理？</p>
<p>ConcurrentHashMap 为什么放弃了分段锁？</p>
</blockquote>
<p>基础数据结构原理和 <code>HashMap</code> 一样，JDK 1.7 采用 数组＋单链表；JDK 1.8 采用数组＋单链表＋红黑树。</p>
<p>并发安全特性的实现：</p>
<p>JDK 1.7：</p>
<ul>
<li>使用分段锁，设计思路是缩小锁粒度，提高并发吞吐。</li>
<li>写数据时，会使用可重入锁去锁住分段（segment）。</li>
</ul>
<p>JDK 1.8：</p>
<ul>
<li>取消分段锁，直接采用 <code>transient volatile HashEntry&lt;K,V&gt;[] table</code> 保存数据，采用 table 数组元素作为锁，从而实现了对每一行数据进行加锁，进一步减少并发冲突的概率。</li>
<li>写数据时，使用是 CAS + <code>synchronized</code>。<ul>
<li>根据 key 计算出 hashcode 。</li>
<li>判断是否需要进行初始化。</li>
<li><code>f</code> 即为当前 key 定位出的 Node，如果为空表示当前位置可以写入数据，利用 CAS 尝试写入，失败则自旋保证成功。</li>
<li>如果当前位置的 <code>hashcode == MOVED == -1</code>,则需要进行扩容。</li>
<li>如果都不满足，则利用 synchronized 锁写入数据。</li>
<li>如果数量大于 <code>TREEIFY_THRESHOLD</code> 则要转换为红黑树。</li>
</ul>
</li>
</ul>
<h4 id="⭐⭐-CopyOnWriteArrayList"><a href="#⭐⭐-CopyOnWriteArrayList" class="headerlink" title="⭐⭐ CopyOnWriteArrayList"></a>⭐⭐ CopyOnWriteArrayList</h4><blockquote>
<p>CopyOnWriteArrayList 的作用？</p>
<p>CopyOnWriteArrayList 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>CopyOnWrite 字面意思为写入时复制。CopyOnWriteArrayList 是线程安全的 ArrayList。</p>
<p><strong>原理</strong></p>
<ul>
<li>在 <code>CopyOnWriteAarrayList</code> 中，读操作不同步，因为它们在内部数组的快照上工作，所以多个迭代器可以同时遍历而不会相互阻塞（1,2,4）。</li>
<li>所有的写操作都是同步的。他们在备份数组（3）的副本上工作。写操作完成后，后备阵列将被替换为复制的阵列，并释放锁定。支持数组变得易变，所以替换数组的调用是原子（5）。</li>
<li>写操作后创建的迭代器将能够看到修改的结构（6,7）。</li>
<li>写时复制集合返回的迭代器不会抛出 ConcurrentModificationException，因为它们在数组的快照上工作，并且无论后续的修改（2,4）如何，都会像迭代器创建时那样完全返回元素。</li>
</ul>
<p align="center">
  <img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/container/CopyOnWriteArrayList.png">
</p>

<h3 id="并发锁"><a href="#并发锁" class="headerlink" title="并发锁"></a>并发锁</h3><blockquote>
<p>👉 参考阅读：：<a href="/posts/6216bb38" title="Java锁">🚀 java 并发锁</a></p>
</blockquote>
<h4 id="⭐⭐-锁类型"><a href="#⭐⭐-锁类型" class="headerlink" title="⭐⭐ 锁类型"></a>⭐⭐ 锁类型</h4><blockquote>
<p>Java 中有哪些锁？</p>
<p>这些锁有什么特性？</p>
</blockquote>
<p><strong>可重入锁</strong></p>
<ul>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code> 是可重入锁</strong>。这点，从其命名也不难看出。</li>
<li><strong><code>synchronized</code> 也是一个可重入锁</strong>。</li>
</ul>
<p><strong>公平锁与非公平锁</strong></p>
<ul>
<li><strong><code>synchronized</code> 只支持非公平锁</strong>。</li>
<li><strong><code>ReentrantLock</code> 、<code>ReentrantReadWriteLock</code>，默认是非公平锁，但支持公平锁</strong>。</li>
</ul>
<p><strong>独享锁与共享锁</strong></p>
<ul>
<li><strong><code>synchronized</code> 、<code>ReentrantLock</code> 只支持独享锁</strong>。</li>
<li><strong><code>ReentrantReadWriteLock</code> 其写锁是独享锁，其读锁是共享锁</strong>。读锁是共享锁使得并发读是非常高效的，读写，写读 ，写写的过程是互斥的。</li>
</ul>
<p><strong>悲观锁与乐观锁</strong></p>
<ul>
<li><p>悲观锁在 Java 中的应用就是通过使用 <code>synchronized</code> 和 <code>Lock</code> 显示加锁来进行互斥同步，这是一种阻塞同步。</p>
</li>
<li><p>乐观锁在 Java 中的应用就是采用 CAS 机制（CAS 操作通过 <code>Unsafe</code> 类提供，但这个类不直接暴露为 API，所以都是间接使用，如各种原子类）。</p>
</li>
</ul>
<p><strong>偏向锁、轻量级锁、重量级锁</strong></p>
<p>Java 1.6 以前，重量级锁一般指的是 <code>synchronized</code> ，而轻量级锁指的是 <code>volatile</code>。</p>
<p>Java 1.6 以后，针对 <code>synchronized</code> 做了大量优化，引入 4 种锁状态： 无锁状态、偏向锁、轻量级锁和重量级锁。锁可以单向的从偏向锁升级到轻量级锁，再从轻量级锁升级到重量级锁 。</p>
<p><strong>分段锁</strong></p>
<p>分段锁其实是一种锁的设计，并不是具体的一种锁。典型：JDK1.7 之前的 <code>ConcurrentHashMap</code></p>
<p><strong>显示锁和内置锁</strong></p>
<ul>
<li>内置锁：<code>synchronized</code></li>
<li>显示锁：<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code> 等。</li>
</ul>
<h4 id="⭐⭐-AQS"><a href="#⭐⭐-AQS" class="headerlink" title="⭐⭐ AQS"></a>⭐⭐ AQS</h4><blockquote>
<p>什么是 AQS？</p>
<p>AQS 的作用是什么？</p>
<p>AQS 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><code>AbstractQueuedSynchronizer</code>（简称 <strong>AQS</strong>）是<strong>队列同步器</strong>，顾名思义，其主要作用是处理同步。它是并发锁和很多同步工具类的实现基石（如 <code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>、<code>Semaphore</code> 等）。</p>
<p><strong>AQS 提供了对独享锁与共享锁的支持</strong>。</p>
<p><strong>原理</strong></p>
<p>（1）数据结构</p>
<ul>
<li><code>state</code> - AQS 使用一个整型的 <code>volatile</code> 变量来 <strong>维护同步状态</strong>。<ul>
<li>这个整数状态的意义由子类来赋予，如<code>ReentrantLock</code> 中该状态值表示所有者线程已经重复获取该锁的次数，<code>Semaphore</code> 中该状态值表示剩余的许可数量。</li>
</ul>
</li>
<li><code>head</code> 和 <code>tail</code> - AQS <strong>维护了一个 <code>Node</code> 类型（AQS 的内部类）的双链表来完成同步状态的管理</strong>。这个双链表是一个双向的 FIFO 队列，通过 <code>head</code> 和 <code>tail</code> 指针进行访问。当 <strong>有线程获取锁失败后，就被添加到队列末尾</strong>。</li>
</ul>
<p>（2）获取独占锁</p>
<p>AQS 中使用 <code>acquire(int arg)</code> 方法获取独占锁，其大致流程如下：</p>
<ol>
<li>先尝试获取同步状态，如果获取同步状态成功，则结束方法，直接返回。</li>
<li>如果获取同步状态不成功，AQS 会不断尝试利用 CAS 操作将当前线程插入等待同步队列的队尾，直到成功为止。</li>
<li>接着，不断尝试为等待队列中的线程节点获取独占锁。</li>
</ol>
<p>（3）释放独占锁</p>
<p>AQS 中使用 <code>release(int arg)</code> 方法释放独占锁，其大致流程如下：</p>
<ol>
<li>先尝试获取解锁线程的同步状态，如果获取同步状态不成功，则结束方法，直接返回。</li>
<li>如果获取同步状态成功，AQS 会尝试唤醒当前线程节点的后继节点。</li>
</ol>
<p>（4）获取共享锁</p>
<p>AQS 中使用 <code>acquireShared(int arg)</code> 方法获取共享锁。</p>
<p><code>acquireShared</code> 方法和 <code>acquire</code> 方法的逻辑很相似，区别仅在于自旋的条件以及节点出队的操作有所不同。</p>
<p>成功获得共享锁的条件如下：</p>
<ul>
<li><code>tryAcquireShared(arg)</code> 返回值大于等于 0 （这意味着共享锁的 permit 还没有用完）。</li>
<li>当前节点的前驱节点是头结点。</li>
</ul>
<p>（5）释放共享锁</p>
<p>AQS 中使用 <code>releaseShared(int arg)</code> 方法释放共享锁。</p>
<p><code>releaseShared</code> 首先会尝试释放同步状态，如果成功，则解锁一个或多个后继线程节点。释放共享锁和释放独享锁流程大体相似，区别在于：</p>
<p>对于独享模式，如果需要 SIGNAL，释放仅相当于调用头节点的 <code>unparkSuccessor</code>。</p>
<h4 id="⭐⭐-ReentrantLock"><a href="#⭐⭐-ReentrantLock" class="headerlink" title="⭐⭐ ReentrantLock"></a>⭐⭐ ReentrantLock</h4><blockquote>
<p>什么是 ReentrantLock？</p>
<p>什么是可重入锁？</p>
<p>ReentrantLock 有什么用？</p>
<p>ReentrantLock 原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><strong><code>ReentrantLock</code> 提供了一组无条件的、可轮询的、定时的以及可中断的锁操作</strong></p>
<p><code>ReentrantLock</code> 的特性如下：</p>
<ul>
<li><strong><code>ReentrantLock</code> 提供了与 <code>synchronized</code> 相同的互斥性、内存可见性和可重入性</strong>。</li>
<li><code>ReentrantLock</code> 支持公平锁和非公平锁（默认）两种模式。</li>
<li><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，支持了 <code>synchronized</code> 所不具备的<strong>灵活性</strong>。<ul>
<li><code>synchronized</code> 无法中断一个正在等待获取锁的线程</li>
<li><code>synchronized</code> 无法在请求获取一个锁时无休止地等待</li>
</ul>
</li>
</ul>
<p><strong>原理</strong></p>
<p><code>ReentrantLock</code> 基于其内部类 <code>ReentrantLock.Sync</code> 实现，<code>Sync</code> 继承自 AQS。它有两个子类：</p>
<ul>
<li><code>ReentrantLock.FairSync</code> - 公平锁。</li>
<li><code>ReentrantLock.NonfairSync</code> - 非公平锁。</li>
</ul>
<p>本质上，就是基于 AQS 实现。</p>
<h4 id="⭐-ReentrantReadWriteLock"><a href="#⭐-ReentrantReadWriteLock" class="headerlink" title="⭐ ReentrantReadWriteLock"></a>⭐ ReentrantReadWriteLock</h4><blockquote>
<p>ReentrantReadWriteLock 是什么？</p>
<p>ReentrantReadWriteLock 的作用？</p>
<p>ReentrantReadWriteLock 的原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p><code>ReentrantReadWriteLock</code> 是一个<strong>可重入的读写锁</strong>。<strong><code>ReentrantReadWriteLock</code> 维护了一对读写锁，将读写锁分开，有利于提高并发效率</strong>。</p>
<p><strong>原理</strong></p>
<p><code>ReentrantReadWriteLock</code> 本质上也是基于 AQS 实现。有三个核心字段：</p>
<ul>
<li><code>sync</code> - 内部类 <code>ReentrantReadWriteLock.Sync</code> 对象。与 <code>ReentrantLock</code> 类似，它有两个子类：<code>ReentrantReadWriteLock.FairSync</code> 和 <code>ReentrantReadWriteLock.NonfairSync</code> ，分别表示公平锁和非公平锁的实现。</li>
<li><code>readerLock</code> - 内部类 <code>ReentrantReadWriteLock.ReadLock</code> 对象，这是一把读锁。</li>
<li><code>writerLock</code> - 内部类 <code>ReentrantReadWriteLock.WriteLock</code> 对象，这是一把写锁。</li>
</ul>
<h4 id="⭐-Condition"><a href="#⭐-Condition" class="headerlink" title="⭐ Condition"></a>⭐ Condition</h4><blockquote>
<p>Condition 有什么用？</p>
<p>使用 Lock 的线程，彼此如何通信？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>可以理解为，什么样的锁配什么样的钥匙。</p>
<p><strong>内置锁（<code>synchronized</code>）配合内置条件队列（<code>wait</code>、<code>notify</code>、<code>notifyAll</code> ），显式锁（<code>Lock</code>）配合显式条件队列（<code>Condition</code> ）</strong>。</p>
<h4 id="⭐⭐-死锁"><a href="#⭐⭐-死锁" class="headerlink" title="⭐⭐ 死锁"></a>⭐⭐ 死锁</h4><blockquote>
<p>如何避免死锁？</p>
</blockquote>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁 lock.tryLock(timeout)，避免锁一直不能释放</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接中里，否则会出现解锁失败的情况。</li>
</ul>
<h3 id="原子变量类"><a href="#原子变量类" class="headerlink" title="原子变量类"></a>原子变量类</h3><h4 id="⭐-原子类简介"><a href="#⭐-原子类简介" class="headerlink" title="⭐ 原子类简介"></a>⭐ 原子类简介</h4><blockquote>
<p>为什么要用原子类？</p>
<p>用过哪些原子类？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>常规的锁（<code>Lock</code>、<code>sychronized</code>）由于是阻塞式的，势必影响并发吞吐量。</p>
<p><code>volatile</code> 号称轻量级的锁，但不能保证原子性。</p>
<p>为了兼顾原子性和锁的性能问题，所以引入了原子类。</p>
<p><strong>类型</strong></p>
<p>原子变量类可以分为 4 组：</p>
<ul>
<li>基本类型<ul>
<li><code>AtomicBoolean</code> - 布尔类型原子类</li>
<li><code>AtomicInteger</code> - 整型原子类</li>
<li><code>AtomicLong</code> - 长整型原子类</li>
</ul>
</li>
<li>引用类型<ul>
<li><code>AtomicReference</code> - 引用类型原子类</li>
<li><code>AtomicMarkableReference</code> - 带有标记位的引用类型原子类</li>
<li><code>AtomicStampedReference</code> - 带有版本号的引用类型原子类</li>
</ul>
</li>
<li>数组类型<ul>
<li><code>AtomicIntegerArray</code> - 整形数组原子类</li>
<li><code>AtomicLongArray</code> - 长整型数组原子类</li>
<li><code>AtomicReferenceArray</code> - 引用类型数组原子类</li>
</ul>
</li>
<li>属性更新器类型<ul>
<li><code>AtomicIntegerFieldUpdater</code> - 整型字段的原子更新器。</li>
<li><code>AtomicLongFieldUpdater</code> - 长整型字段的原子更新器。</li>
<li><code>AtomicReferenceFieldUpdater</code> - 原子更新引用类型里的字段。</li>
</ul>
</li>
</ul>
<h4 id="⭐-原子类的原理"><a href="#⭐-原子类的原理" class="headerlink" title="⭐ 原子类的原理"></a>⭐ 原子类的原理</h4><ol>
<li>处理器实现原子操作：使用总线锁保证原子性，使用缓存锁保证原子性（修改内存地址，缓存一致性机制：阻止同时修改由 2 个以上的处理器缓存的内存区域数据）</li>
<li>JAVA 实现原子操作：循环使用 CAS （自旋 CAS）实现原子操作</li>
</ol>
<h3 id="并发工具类"><a href="#并发工具类" class="headerlink" title="并发工具类"></a>并发工具类</h3><blockquote>
<p>👉 参考阅读：：<a href="/posts/19b32c42" title="Java并发工具类">🚀 java 并发工具类</a></p>
</blockquote>
<h4 id="⭐-CountDownLatch"><a href="#⭐-CountDownLatch" class="headerlink" title="⭐ CountDownLatch"></a>⭐ CountDownLatch</h4><blockquote>
<p>CountDownLatch 作用？</p>
<p>CountDownLatch 原理？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思为 <strong>递减计数锁</strong>。用于控制一个或者多个线程等待多个线程。</p>
<p><code>CountDownLatch</code> 维护一个计数器 count，表示需要等待的事件数量。<code>countDown</code> 方法递减计数器，表示有一个事件已经发生。调用 <code>await</code> 方法的线程会一直阻塞直到计数器为零，或者等待中的线程中断，或者等待超时。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CountDownLatch.png" alt="img"></p>
<p><strong>原理</strong></p>
<p><code>CountDownLatch</code> 是基于 AQS(<code>AbstractQueuedSynchronizer</code>) 实现的。</p>
<h4 id="⭐-CyclicBarrier"><a href="#⭐-CyclicBarrier" class="headerlink" title="⭐ CyclicBarrier"></a>⭐ CyclicBarrier</h4><blockquote>
<p>CyclicBarrier 有什么用？</p>
<p>CyclicBarrier 的原理是什么？</p>
<p>CyclicBarrier 和 CountDownLatch 有什么区别？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思是 <strong>循环栅栏</strong>。<strong><code>CyclicBarrier</code> 可以让一组线程等待至某个状态（遵循字面意思，不妨称这个状态为栅栏）之后再全部同时执行</strong>。之所以叫循环栅栏是因为：当所有等待线程都被释放以后，<code>CyclicBarrier</code> 可以被重用。</p>
<p><code>CyclicBarrier</code> 维护一个计数器 count。每次执行 <code>await</code> 方法之后，count 加 1，直到计数器的值和设置的值相等，等待的所有线程才会继续执行。</p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/CyclicBarrier.png" alt="img"></p>
<p><strong>原理</strong></p>
<p><code>CyclicBarrier</code> 是基于 <code>ReentrantLock</code> 和 <code>Condition</code> 实现的。</p>
<p><strong>区别</strong></p>
<p><code>CyclicBarrier</code> 和 <code>CountDownLatch</code> 都可以用来让一组线程等待其它线程。与 <code>CyclicBarrier</code> 不同的是，<code>CountdownLatch</code> 不能重用。</p>
<h4 id="⭐-Semaphore"><a href="#⭐-Semaphore" class="headerlink" title="⭐ Semaphore"></a>⭐ Semaphore</h4><blockquote>
<p>Semaphore 作用？</p>
</blockquote>
<p><strong>作用</strong></p>
<p>字面意思为 <strong>信号量</strong>。<code>Semaphore</code> 用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。</p>
<p><code>Semaphore</code> 管理着一组虚拟的许可（permit），permit 的初始数量可通过构造方法来指定。每次执行 <code>acquire</code> 方法可以获取一个 permit，如果没有就等待；而 <code>release</code> 方法可以释放一个 permit。</p>
<ul>
<li><code>Semaphore</code> 可以用于实现资源池，如数据库连接池。</li>
<li><code>Semaphore</code> 可以用于将任何一种容器变成有界阻塞容器。</li>
</ul>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/Semaphore.png" alt="img"></p>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><h4 id="⭐⭐-ThreadPoolExecutor"><a href="#⭐⭐-ThreadPoolExecutor" class="headerlink" title="⭐⭐ ThreadPoolExecutor"></a>⭐⭐ ThreadPoolExecutor</h4><blockquote>
<p><code>ThreadPoolExecutor</code> 有哪些参数，各自有什么用？</p>
<p><code>ThreadPoolExecutor</code> 工作原理？</p>
</blockquote>
<p><strong>原理</strong></p>
<p><img src="https://raw.githubusercontent.com/dunwu/images/master/cs/java/javacore/concurrent/java-thread-pool_1.png" alt="img"></p>
<p><strong>参数</strong></p>
<p><code>java.uitl.concurrent.ThreadPoolExecutor</code> 类是 <code>Executor</code> 框架中最核心的一个类。</p>
<p>ThreadPoolExecutor 有四个构造方法，前三个都是基于第四个实现。第四个构造方法定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">ThreadPoolExecutor</span><span class="params">(<span class="type">int</span> corePoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">int</span> maximumPoolSize,</span></span><br><span class="line"><span class="params">                          <span class="type">long</span> keepAliveTime,</span></span><br><span class="line"><span class="params">                          TimeUnit unit,</span></span><br><span class="line"><span class="params">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="params">                          ThreadFactory threadFactory,</span></span><br><span class="line"><span class="params">                          RejectedExecutionHandler handler)</span> &#123;</span><br></pre></td></tr></table></figure>

<p>参数说明：</p>
<ul>
<li><code>corePoolSize</code> - <strong>核心线程数量</strong>。当有新任务通过 <code>execute</code> 方法提交时 ，线程池会执行以下判断：<ul>
<li>如果运行的线程数少于 <code>corePoolSize</code>，则创建新线程来处理任务，即使线程池中的其他线程是空闲的。</li>
<li>如果线程池中的线程数量大于等于 <code>corePoolSize</code> 且小于 <code>maximumPoolSize</code>，则只有当 <code>workQueue</code> 满时才创建新的线程去处理任务；</li>
<li>如果设置的 <code>corePoolSize</code> 和 <code>maximumPoolSize</code> 相同，则创建的线程池的大小是固定的。这时如果有新任务提交，若 <code>workQueue</code> 未满，则将请求放入 <code>workQueue</code> 中，等待有空闲的线程去从 <code>workQueue</code> 中取任务并处理；</li>
<li>如果运行的线程数量大于等于 <code>maximumPoolSize</code>，这时如果 <code>workQueue</code> 已经满了，则使用 <code>handler</code> 所指定的策略来处理任务；</li>
<li>所以，任务提交时，判断的顺序为 <code>corePoolSize</code> &#x3D;&gt; <code>workQueue</code> &#x3D;&gt; <code>maximumPoolSize</code>。</li>
</ul>
</li>
<li><code>maximumPoolSize</code> - <strong>最大线程数量</strong>。<ul>
<li>如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。</li>
<li>值得注意的是：如果使用了无界的任务队列这个参数就没什么效果。</li>
</ul>
</li>
<li><code>keepAliveTime</code>：<strong>线程保持活动的时间</strong>。<ul>
<li>当线程池中的线程数量大于 <code>corePoolSize</code> 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>。</li>
<li>所以，如果任务很多，并且每个任务执行的时间比较短，可以调大这个时间，提高线程的利用率。</li>
</ul>
</li>
<li><code>unit</code> - <strong><code>keepAliveTime</code> 的时间单位</strong>。有 7 种取值。可选的单位有天（DAYS），小时（HOURS），分钟（MINUTES），毫秒(MILLISECONDS)，微秒(MICROSECONDS, 千分之一毫秒)和毫微秒(NANOSECONDS, 千分之一微秒)。</li>
<li><code>workQueue</code> - <strong>等待执行的任务队列</strong>。用于保存等待执行的任务的阻塞队列。 可以选择以下几个阻塞队列。<ul>
<li><code>ArrayBlockingQueue</code> - <strong>有界阻塞队列</strong>。<ul>
<li>此队列是<strong>基于数组的先进先出队列（FIFO）</strong>。</li>
<li>此队列创建时必须指定大小。</li>
</ul>
</li>
<li><code>LinkedBlockingQueue</code> - <strong>无界阻塞队列</strong>。<ul>
<li>此队列是<strong>基于链表的先进先出队列（FIFO）</strong>。</li>
<li>如果创建时没有指定此队列大小，则默认为 <code>Integer.MAX_VALUE</code>。</li>
<li>吞吐量通常要高于 <code>ArrayBlockingQueue</code>。</li>
<li>使用 <code>LinkedBlockingQueue</code> 意味着： <code>maximumPoolSize</code> 将不起作用，线程池能创建的最大线程数为 <code>corePoolSize</code>，因为任务等待队列是无界队列。</li>
<li><code>Executors.newFixedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
<li><code>SynchronousQueue</code> - <strong>不会保存提交的任务，而是将直接新建一个线程来执行新来的任务</strong>。<ul>
<li>每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态。</li>
<li>吞吐量通常要高于 <code>LinkedBlockingQueue</code>。</li>
<li><code>Executors.newCachedThreadPool</code> 使用了这个队列。</li>
</ul>
</li>
<li><code>PriorityBlockingQueue</code> - <strong>具有优先级的无界阻塞队列</strong>。</li>
</ul>
</li>
<li><code>threadFactory</code> - <strong>线程工厂</strong>。可以通过线程工厂给每个创建出来的线程设置更有意义的名字。</li>
<li><code>handler</code> - <strong>饱和策略</strong>。它是 <code>RejectedExecutionHandler</code> 类型的变量。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。线程池支持以下策略：<ul>
<li><code>AbortPolicy</code> - 丢弃任务并抛出异常。这也是默认策略。</li>
<li><code>DiscardPolicy</code> - 丢弃任务，但不抛出异常。</li>
<li><code>DiscardOldestPolicy</code> - 丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）。</li>
<li><code>CallerRunsPolicy</code> - 只用调用者所在的线程来运行任务。</li>
<li>如果以上策略都不能满足需要，也可以通过实现 <code>RejectedExecutionHandler</code> 接口来定制处理策略。如记录日志或持久化不能处理的任务。</li>
</ul>
</li>
</ul>
<h4 id="⭐-Executors"><a href="#⭐-Executors" class="headerlink" title="⭐ Executors"></a>⭐ Executors</h4><blockquote>
<p>Executors 提供了哪些内置的线程池？</p>
<p>这些线程池各自有什么特性？适合用于什么场景？</p>
</blockquote>
<p>Executors 为 Executor，ExecutorService，ScheduledExecutorService，ThreadFactory 和 <code>Callable</code> 类提供了一些工具方法。</p>
<p>（1）newSingleThreadExecutor</p>
<p><strong>创建一个单线程的线程池</strong>。</p>
<p>只会创建唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。 <strong>如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它</strong> 。</p>
<p>单工作线程最大的特点是：<strong>可保证顺序地执行各个任务</strong>。</p>
<p>（2）newFixedThreadPool</p>
<p><strong>创建一个固定大小的线程池</strong>。</p>
<p><strong>每次提交一个任务就会新创建一个工作线程，如果工作线程数量达到线程池最大线程数，则将提交的任务存入到阻塞队列中</strong>。</p>
<p><code>FixedThreadPool</code> 是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。</p>
<p>（3）newCachedThreadPool</p>
<p><strong>创建一个可缓存的线程池</strong>。</p>
<ul>
<li>如果线程池大小超过处理任务所需要的线程数，就会回收部分空闲的线程；</li>
<li>如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间（默认为 1 分钟），则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。</li>
<li>此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说 JVM）能够创建的最大线程大小。 因此，使用 <code>CachedThreadPool</code> 时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统瘫痪。</li>
</ul>
<p>（4）newScheduleThreadPool</p>
<p>创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。</p>
<h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><blockquote>
<p>类的生命周期是什么？</p>
<p>了解类加载器吗,JVM类加载的机制是什么？</p>
<p>👉 参考阅读：<a href="/posts/5eb9d1ec" title="jvm类加载">🚀 JVM 类加载</a></p>
</blockquote>
<h4 id="对象的创建过程了解吗？"><a href="#对象的创建过程了解吗？" class="headerlink" title="对象的创建过程了解吗？"></a>对象的创建过程了解吗？</h4><p><img src="https://raw.githubusercontent.com/coder-xuyong/coder-xuyong/main/img/blog/java/jvm/jvm_1.png" alt="对象创建过程"></p>
<p>虚拟机收到new指令触发。<br><strong>类加载检查</strong>：如果类没有被类加载器加载，则执行类加载流程（将class信息加载到JVM的运行时数据区的过程），对象所需内存大小在类加载完后可以完全确定。<br><strong>对象分配内存</strong>：从堆中划分出一块确定大小的内存。<br><strong>内存空间初始化</strong>：内存分配完后，虚拟机需要将分配到的内存空间初始化为零值（如：int值为0，boolean值为false等），保证了对象的实例字段在Java代码中可以直接使用。<br><strong>为对象进行必要的设置</strong>：虚拟机为对象进行设置，如设置对象属于哪个类的实例、如何找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息，这些信息存放在对象头中。</p>
<p>从虚拟机的角度来看，一个新的对象已经创建完毕。但从Java程序的角度来看，对象创建才刚开始，所有的字段还是零值，所以需要程序员进行初始化操作，这样一个真正可用的对象才算完全产生出来。</p>
<h4 id="JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的"><a href="#JVM-里-new-对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的" class="headerlink" title="JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的?"></a>JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的?</h4><p>对象创建在虚拟机中是非常频繁的操作，即使仅仅修改一个指针所指向的位置，在并发情况下也会引起<strong>线程不安全</strong>。</p>
<ul>
<li>采用CAS分配重试的方式来保证更新操作的原子性</li>
<li>每个线程在Java堆中预先分配一小块内存，也就是本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），要分配内存的线程，先在本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li>
</ul>
<h4 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局?"></a>对象的内存布局?</h4><p> 参考阅读：<a href="/posts/b9e487ed.html#Java%E5%AF%B9%E8%B1%A1%E5%A4%B4" title="Java并发核心机制">🚀 Java对象头</a></p>
<h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><h4 id="对象内存分配方式"><a href="#对象内存分配方式" class="headerlink" title="对象内存分配方式"></a>对象内存分配方式</h4><p>虚拟机为新对象分配内存，从堆中划出一块确定大小的内存，因为对象所需内存的大小在类加载完后可以完全确定。</p>
<p>堆内存是否规整：<br><img src="https://raw.githubusercontent.com/coder-xuyong/coder-xuyong/main/img/blog/java/jvm/jvm_2.png" alt="堆内存"></p>
<ul>
<li>堆内存规整：已使用的内存在一边，未使用内存在另一边。</li>
<li>堆内存不规整：已使用内存和未使用相互交错。</li>
</ul>
<p>堆内存是否规整是由垃圾收集器是否带有压缩整理功能决定的。</p>
<p><strong>内存分配方式：</strong></p>
<p>分配方式的选择 取决于 Java堆内存是否规整：</p>
<ul>
<li>指针碰撞方式：<ul>
<li>堆内存绝对规整。</li>
<li>分配过程：将已使用内存和为使用内存之间放一个分界点的指针，分配内存时，指针会向未使用内存方向移动，移动一段与对象大小相等的距离。<br><img src="https://raw.githubusercontent.com/coder-xuyong/coder-xuyong/main/img/blog/java/jvm/jvm_3.png" alt="对象内存分配"></li>
</ul>
</li>
<li>空闲列表：<ul>
<li>堆内存不规整。</li>
<li>分配过程：虚拟机内部维护了一个记录可用内存块的列表，在分配时从列表找一块足够大的空间划分给对象实例，并更新列表上的记录。</li>
</ul>
</li>
</ul>
<p>Java堆是否规整 由所采用的垃圾收集器是否带有压缩整理功能决定</p>
<h4 id="能说一下JVM的内存区域吗？"><a href="#能说一下JVM的内存区域吗？" class="headerlink" title="能说一下JVM的内存区域吗？"></a>能说一下JVM的内存区域吗？</h4><blockquote>
<p>👉 参考阅读：<a href="/posts/f0675471" title="jvm简介与内存架构">🚀 JVM简介与内存架构</a></p>
</blockquote>
<h3 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h3><h4 id="如何判断对象仍然存活？"><a href="#如何判断对象仍然存活？" class="headerlink" title="如何判断对象仍然存活？"></a>如何判断对象仍然存活？</h4><p><strong>reference count（引用计数）</strong><br>查看是否有引用指向该对象，有则说明该对象不是垃圾，反之就是垃圾。</p>
<h4 id="垃圾收集算法了解吗？"><a href="#垃圾收集算法了解吗？" class="headerlink" title="垃圾收集算法了解吗？"></a>垃圾收集算法了解吗？</h4><p>垃圾收集算法主要有三种：</p>
<ol>
<li>标记-清除算法</li>
<li>标记-复制算法</li>
<li>标记-整理算法</li>
</ol>
<blockquote>
<p>👉 参考阅读：<a href="/posts/a0b1cb9c.html#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95" title="jvm垃圾回收">🚀 JVM垃圾收集算法</a></p>
</blockquote>
<h4 id="并发标记清除收集器"><a href="#并发标记清除收集器" class="headerlink" title="并发标记清除收集器"></a>并发标记清除收集器</h4><blockquote>
<p>能详细说一下CMS收集器的垃圾收集过程吗？</p>
<p>G1垃圾收集器了解吗？</p>
<p>有了CMS，为什么还要引入G1？</p>
</blockquote>
<blockquote>
<p>👉 参考阅读：<a href="/posts/a0b1cb9c.html#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%94%B6%E9%9B%86%E5%99%A8" title="jvm垃圾回收">🚀 JVM并发标记清除收集器</a></p>
</blockquote>
<h3 id="OOM"><a href="#OOM" class="headerlink" title="OOM"></a>OOM</h3><h4 id="内存泄漏可能由哪些原因导致呢？"><a href="#内存泄漏可能由哪些原因导致呢？" class="headerlink" title="内存泄漏可能由哪些原因导致呢？"></a>内存泄漏可能由哪些原因导致呢？</h4><p>数据连接、IO、Socket等连接;threadLocal</p>
<h4 id="了解哪些性JVM监控和故障处理工具？"><a href="#了解哪些性JVM监控和故障处理工具？" class="headerlink" title="了解哪些性JVM监控和故障处理工具？"></a>了解哪些性JVM监控和故障处理工具？</h4><p>可以使用堆内存诊断工具（JDK内）来监测堆：</p>
<ul>
<li>jsp工具（查看当前系统中有哪些java程序，可以查看当前Java程序中有那些线程）</li>
<li>Jmap工具（查看堆内存占用情况：Jmap -head 进程id）</li>
<li>jconsole(图像界面的多功能检测工具，可以连续监测)</li>
<li>jvisualvm（和jconsole有点像）</li>
</ul>
<h4 id="JVM的常见参数配置知道哪些"><a href="#JVM的常见参数配置知道哪些" class="headerlink" title="JVM的常见参数配置知道哪些?"></a>JVM的常见参数配置知道哪些?</h4><p>一些常见的参数配置：<br><strong>堆配置：</strong></p>
<ul>
<li>-Xms:初始堆大小</li>
<li>-Xms：最大堆大小</li>
<li>-XX:NewSize&#x3D;n:设置年轻代大小</li>
<li>-XX:NewRatio&#x3D;n:设置年轻代和年老代的比值。如：为3表示年轻代和年老代比值为1：3，年轻代占整个年轻代年老代和的1&#x2F;4</li>
<li>-XX:SurvivorRatio&#x3D;n:年轻代中Eden区与两个Survivor区的比值。注意Survivor区有两个。如3表示Eden：3 Survivor：2，一个Survivor区占整个年轻代的1&#x2F;5</li>
<li>-XX:MaxPermSize&#x3D;n:设置持久代大小<br><strong>gc设置：</strong></li>
<li>-XX:+UseSerialGC:设置串行收集器</li>
<li>-XX:+UseParallelGC:设置并行收集器</li>
<li>-XX:+UseParalledlOldGC:设置并行年老代收集器</li>
<li>-XX:+UseConcMarkSweepGC:设置并发收集器</li>
<li>-XX:+UseG1GC<br><strong>并行收集器设置</strong></li>
<li>-XX:ParallelGCThreads&#x3D;n:设置并行收集器收集时使用的CPU数。并行收集线程数</li>
<li>-XX:MaxGCPauseMillis&#x3D;n:设置并行收集最大的暂停时间（如果到这个时间了，垃圾回收器依然没有回收完，也会停止回收）</li>
<li>-XX:GCTimeRatio&#x3D;n:设置垃圾回收时间占程序运行时间的百分比。公式为：1&#x2F;(1+n)</li>
<li>-XX:+CMSIncrementalMode:设置为增量模式。适用于单CPU情况</li>
<li>-XX:ParallelGCThreads&#x3D;n:设置并发收集器年轻代手机方式为并行收集时，使用的CPU数。并行收集线程数<br><strong>打印GC回收的过程日志信息</strong></li>
<li>-XX:+PrintGC</li>
<li>-XX:+PrintGCDetails</li>
<li>-XX:+PrintGCTimeStamps</li>
<li>-Xloggc:filename</li>
</ul>
<h4 id="线上服务CPU占用过高怎么排查？"><a href="#线上服务CPU占用过高怎么排查？" class="headerlink" title="线上服务CPU占用过高怎么排查？"></a>线上服务CPU占用过高怎么排查？</h4><p>CPU飙高<br>1、所以先需要找出那个进程占用CPU高。</p>
<ul>
<li>top  列出系统各个进程的资源占用情况。<br>2、然后根据找到对应进行里哪个线程占用CPU高。</li>
<li>top -Hp 进程ID   列出对应进程里面的线程占用资源情况<br>3、找到对应线程ID后，再打印出对应线程的堆栈信息</li>
<li>printf “%x\n”  PID    把线程ID转换为16进制。</li>
<li>jstack PID 打印出进程的所有线程信息，从打印出来的线程信息中找到上一步转换为16进制的线程ID对应的线程信息。<br>4、最后根据线程的堆栈信息定位到具体业务方法,从代码逻辑中找到问题所在。<br>查看是否有线程长时间的watting 或blocked，如果线程长期处于watting状态下， 关注watting on xxxxxx，说明线程在等待这把锁，然后根据锁的地址找到持有锁的线程。</li>
</ul>
<h4 id="内存飙高问题怎么排查？"><a href="#内存飙高问题怎么排查？" class="headerlink" title="内存飙高问题怎么排查？"></a>内存飙高问题怎么排查？</h4><p>分析：内存飚高如果是发生在java进程上，一般是因为创建了大量对象所导致，持续飚高说明垃圾回收跟不上对象创建的速度，或者内存泄露导致对象无法回收。<br>1、先观察垃圾回收的情况</p>
<ul>
<li>jstat -gc PID 1000 查看GC次数，时间等信息，每隔一秒打印一次。</li>
<li>jmap -histo PID | head -20   查看堆内存占用空间最大的前20个对象类型,可初步查看是哪个对象占用了内存。<br>如果每次GC次数频繁，而且每次回收的内存空间也正常，那说明是因为对象创建速度快导致内存一直占用很高；如果每次回收的内存非常少，那么很可能是因为内存泄露导致内存一直无法被回收。<br>2、导出堆内存文件快照</li>
<li>jmap -dump:live,format&#x3D;b,file&#x3D;&#x2F;home&#x2F;myheapdump.hprof PID  dump堆内存信息到文件。<br>如果会挂掉<br>-XX:+HeapDumpOnOutOfMemoryError<br>-XX:HeapDumpPath&#x3D;&#x2F;crashes&#x2F;my-heap-dump.hprof<br>3、使用visualVM对dump文件进行离线分析，找到占用内存高的对象，再找到创建该对象的业务代码位置，从代码和业务场景中定位具体问题。</li>
</ul>
<h4 id="频繁-minor-gc-怎么办？"><a href="#频繁-minor-gc-怎么办？" class="headerlink" title="频繁 minor gc 怎么办？"></a>频繁 minor gc 怎么办？</h4><p>优化Minor GC频繁问题：通常情况下，由于新生代空间较小，Eden区很快被填满，就会导致频繁Minor  GC，因此可以通过增大新生代空间-Xmn来降低Minor GC的频率。</p>
<h4 id="频繁Full-GC怎么办"><a href="#频繁Full-GC怎么办" class="headerlink" title="频繁Full GC怎么办"></a>频繁Full GC怎么办</h4><p>Full GC的排查思路大概如下：</p>
<ol>
<li>清楚从程序角度，有哪些原因导致FGC？</li>
</ol>
<ul>
<li>大对象：系统一次性加载了过多数据到内存中（比如SQL查询未做分页），导致大对象进入了老年代。</li>
<li>内存泄漏：频繁创建了大量对象，但是无法被回收（比如IO对象使用完后未调用close方法释放资源），先引发FGC，最后导致OOM.</li>
<li>程序频繁生成一些长生命周期的对象，当这些对象的存活年龄超过分代年龄时便会进入老年代，最后引发FGC. </li>
<li>程序BUG</li>
<li>代码中显式调用了gc方法，包括自己的代码甚至框架中的代码。</li>
<li>JVM参数设置问题：包括总内存大小、新生代和老年代的大小、Eden区和S区的大小、元空间大小、垃圾回收算法等等。</li>
</ul>
<h4 id="有没有处理过内存溢出-OOM-问题？是如何定位的？"><a href="#有没有处理过内存溢出-OOM-问题？是如何定位的？" class="headerlink" title="有没有处理过内存溢出(OOM)问题？是如何定位的？"></a>有没有处理过内存溢出(OOM)问题？是如何定位的？</h4><p>内存泄漏是内在病源，外在病症表现可能有：</p>
<ul>
<li>应用程序长时间连续运行时性能严重下降</li>
<li>CPU 使用率飙升，甚至到 100%</li>
<li>频繁 Full GC，各种报警，例如接口超时报警等</li>
<li>应用程序抛出 OutOfMemoryError 错误</li>
<li>应用程序偶尔会耗尽连接对象</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a target="_blank" rel="noopener" href="https://dunwu.github.io/">https://dunwu.github.io/</a></li>
<li><a target="_blank" rel="noopener" href="https://www.yuque.com/beyourself-twyxw/vgva7f/36bc1baac2bb9972b514ae644f1d1016">https://www.yuque.com/beyourself-twyxw/vgva7f/36bc1baac2bb9972b514ae644f1d1016</a></li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://coder-xuyong.github.io">coder-xuyong</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://coder-xuyong.github.io/posts/ebd55e42">https://coder-xuyong.github.io/posts/ebd55e42</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://coder-xuyong.github.io" target="_blank">coder-xuyong</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-share"><div class="social-share" data-image="https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/c81d9ccd" title="hexo + butterfly 搭建记录"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/a5219288c7ea486f89f08f40c300d53820250508.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">hexo + butterfly 搭建记录</div></div><div class="info-2"><div class="info-item-1">认识 hexo简单来说，就是一个博客框架。社区很活跃，里面有很懂框架可以直接使用和自定义。更多详情，直接查看官网： https://hexo.io/zh-cn/docs/index.html 🚀 markdown 语法可以查看  本地搭建 hexo 记录1.git 安装：略2.node.js 安装：版本 22，详情略3.启动终端安装框架:npm install -g hexo-cli4.初始化 hexo  123hexo init &lt;folder&gt;cd &lt;folder&gt;npm install 5.在 hexo 根目录终端输入： hexo server，启动程序，访问 http://localhost:4000/ 不报错即成功。 常用命令1.在终端输入 hexo new page 导航栏名字,如：hexo new page about 配置 github pages注意： 创建github 仓库的时候，必须要一个 README.md，不然会失败。  详情查看官网文档：https://hexo.io/zh-cn/docs/github-pages 进阶 Ne...</div></div></div></a><a class="pagination-related" href="/posts/5674b7a7" title="java 整合 modbus"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/7f933184dd4747a0bb326ff1bca1eda720250730.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">java 整合 modbus</div></div><div class="info-2"><div class="info-item-1">整合 modbus 小 demo配置 maven 依赖123456789&lt;dependency&gt;    &lt;groupId&gt;com.infiniteautomation&lt;/groupId&gt;    &lt;artifactId&gt;modbus4j&lt;/artifactId&gt;    &lt;version&gt;3.1.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.apache.commons&lt;/groupId&gt;    &lt;artifactId&gt;commons-lang3&lt;/artifactId&gt;&lt;/dependency&gt;  ModbusServer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class ModbusSe...</div></div></div></a></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><a class="pagination-related" href="/posts/3082f8d4" title="Java 编码和加密"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dddd5d37f41343ac9c0b9500f111fbae20250423.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-15</div><div class="info-item-2">Java 编码和加密</div></div><div class="info-2"><div class="info-item-1">Java 编码和加密Base64 编码Base64 原理Base64 内容传送编码是一种以任意 8 位字节序列组合的描述形式，这种形式不易被人直接识别。 Base64 是一种很常见的编码规范，其作用是将二进制序列转换为人类可读的 ASCII 字符序列，常用在需用通过文本协议（比如 HTTP 和 SMTP）来传输二进制数据的情况下。Base64 并不是加密解密算法，尽管我们有时也听到使用 Base64 来加密解密的说法，但这里所说的加密与解密实际是指编码（encode） 和 解码（decode）的过程，其变换是非常简单的，仅仅能够避免信息被直接识别。 Base64 算法主要是将给定的字符以字符编码(如 ASCII 码，UTF-8 码)对应的十进制数为基准，做编码操作：  将给定的字符串以字符为单位，转换为对应的字符编码。 将获得字符编码转换为二进制 对二进制码做分组转换，每 3 个字节为一组，转换为每 4 个 6 位二进制位一组（不足 6 位时低位补 0）。这是一个分组变化的过程，3 个 8 位二进制码和 4 个 6 位二进制码的长度都是 24 位（3*8 = 4*6 = 24）。...</div></div></div></a><a class="pagination-related" href="/posts/29e7dc52" title="理解 Java 类加载器"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/dcdad1b7aa454b97b412899068f94aa620250313.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-16</div><div class="info-item-2">理解 Java 类加载器</div></div><div class="info-2"><div class="info-item-1">深度理解 Java SPISPI 简介SPI 全称 Service Provider Interface，是 Java 提供的，旨在由第三方实现或扩展的 API，它是一种用于动态加载服务的机制。它的作用是让程序能够自动发现、加载和使用第三方提供的实现，从而实现基于接口的解耦和可插拔的扩展架构。 Java SPI 有四个要素：  SPI 接口：为服务提供者实现类约定的接口或抽象类。 SPI 实现类：实际提供服务的实现类。 SPI 配置：Java SPI 机制约定的配置文件，提供查找服务实现类的逻辑。配置文件必须置于 META-INF/services 目录中，并且，文件名应与服务提供者接口的完全限定名保持一致。文件中的每一行都有一个实现服务类的详细信息，同样是服务提供者类的完全限定名称。 ServiceLoader：Java SPI 的核心类，用于加载 SPI 实现类。 ServiceLoader 中有各种实用方法来获取特定实现、迭代它们或重新加载服务。  SPI 示例 定义接口需要定义一个 SPI 接口，和普通接口并没有什么差别。  123public interface Dat...</div></div></div></a><a class="pagination-related" href="/posts/f0675471" title="jvm简介与内存架构"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/7f933184dd4747a0bb326ff1bca1eda720250730.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-18</div><div class="info-item-2">jvm简介与内存架构</div></div><div class="info-2"><div class="info-item-1">简介 更多信息查看官网  JVM，全称是 Java Virtual Machine，Java运行环境（Java二进制字节码的运行环境） 优点：  是Java一次编写，到处运行的基石。 自动内存管理，垃圾回收功能 数组下标越界检查 多态  JVM有很多，常见的JVM有：HotSpot Opent JDK edition（平时使用的）、Eclipse OpenJ9等 内存架构程序计数器Program Counter Register，程序计数器（寄存器）：作用是记住下一条jvm指令的执行地址，在物理上，是通过cpu中的寄存器来实现的。他是线程私有，且是唯一一个不会存在内存溢出的区域。 工作流程：java源码编译为二进制字节码，字节码中包含jvm指令，这些指令交给解释器-&gt;机器码-&gt;CPU执行。 1234567891011121314151617181920//  二进制字节码                         java 源代码// 其中iconst_x 就是程序计数器0: getstatic    #20                 | PrintStr...</div></div></div></a><a class="pagination-related" href="/posts/a0b1cb9c" title="jvm垃圾回收"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/6edb712c4a9a46bb843646404a0ff2db20250904.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-23</div><div class="info-item-2">jvm垃圾回收</div></div><div class="info-2"><div class="info-item-1">如何判断对象可以回收引用计数法给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。 两个对象出现循环引用的情况下，此时引用计数器永远不为 0，导致无法对它们进行回收。 12345678910public class ReferenceCountingGC &#123;    public Object instance = null;    public static void main(String[] args) &#123;        ReferenceCountingGC objectA = new ReferenceCountingGC();        ReferenceCountingGC objectB = new ReferenceCountingGC();        objectA.instance = objectB;        objectB.instance = objectA;    &#125;&#125;  因为循环引用的存在，所以 Java 虚拟机不适用引用计数算法。 ...</div></div></div></a><a class="pagination-related" href="/posts/d9362458" title="jvm字节码"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/5803ca9faed74b0080a1156e0ef93aae20250529.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-24</div><div class="info-item-2">jvm字节码</div></div><div class="info-2"><div class="info-item-1">字节码Java 字节码是Java虚拟机执行的一种指令格式。之所以被称之为字节码，是因为：Java 字节码文件（.class）是一种以 8 位字节为基础单位的二进制流文件，各个数据项严格按照顺序紧凑地排列在 .class 文件中，中间没有添加任何分隔符。整个 .class 文件本质上就是一张表。 Java 能做到 “一次编译，到处运行”，一是因为 JVM 针对各种操作系统、平台都进行了定制；二是因为无论在什么平台，都可以编译生成固定格式的Java 字节码文件（.class）。 字节码文件结构一个简单的 HelloWorld.java  1234567package cn.itcast.jvm.t5; // HelloWorld 示例public class HelloWorld &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello world&quot;); &#125; &#125;  执行 javac -parameters -d . HellowWorld.jav...</div></div></div></a><a class="pagination-related" href="/posts/5eb9d1ec" title="jvm类加载"><img class="cover" src="https://prod-alicdn-community.kurobbs.com/forum/7f933184dd4747a0bb326ff1bca1eda720250730.jpg?x-oss-process=image%2Fformat%2Cwebp" alt="cover"><div class="info text-center"><div class="info-1"><div class="info-item-1"><i class="far fa-calendar-alt fa-fw"></i> 2025-09-25</div><div class="info-item-2">jvm类加载</div></div><div class="info-2"><div class="info-item-1">类加载机制 类是在运行期间动态加载的。  类的加载指的是将类的 .class 文件中的二进制数据读入到内存中，并转为可执行的代码的过程。 类的生命周期 Java 类的完整生命周期包括图片中这几个阶段： 加载、验证、准备、初始化和卸载这 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始。而解析过程在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。 类加载过程是指加载、验证、准备、解析和初始化这 5 个阶段。 （一）加载加载流程：  通过类的全限定名获取定义此类的二进制字节流 将字节流所代表的静态存储结构转换为方法区的运行时数据结构 在内存中生成一个代表该类的java.lang.Class对象  加载来源：  本地文件系统: .class文件 网络下载: Applet 压缩包: JAR、WAR文件 运行时计算生成: 动态代理 其他文件生成: JSP  （二）验证验证是链接阶段的第一步。验证的目标是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 验证阶段大致会完成 4 个阶段的检验动作：  文...</div></div></div></a></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/medias/img/logo.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">coder-xuyong</div><div class="author-info-description">生如牛马不得闲</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">103</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">100</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">48</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/coder-xuyong"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://coder-xuyong.github.io/resume/?user=coder-xuyong&amp;template=template2" target="_blank" title="resume"><i class="fa-solid fa-address-card" style="color: #hdhfbb;"></i></a><a class="social-icon" href="https://github.com/coder-xuyong" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content is-expand"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80"><span class="toc-number">1.</span> <span class="toc-text">基础</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#String"><span class="toc-number">1.1.1.</span> <span class="toc-text">String</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.</span> <span class="toc-text">面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84"><span class="toc-number">1.3.</span> <span class="toc-text">反射</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%88%9B%E5%BB%BA%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">⭐ 创建实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%8A%A0%E8%BD%BD%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">⭐ 加载实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">1.3.3.</span> <span class="toc-text">⭐⭐ 动态代理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JDK8"><span class="toc-number">1.4.</span> <span class="toc-text">JDK8</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">1.5.</span> <span class="toc-text">其他</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-hashcode"><span class="toc-number">1.5.1.</span> <span class="toc-text">⭐ hashcode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO"><span class="toc-number">2.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#NIO"><span class="toc-number">2.1.</span> <span class="toc-text">NIO</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.2.</span> <span class="toc-text">序列化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%BA%8F%E5%88%97%E5%8C%96%E9%97%AE%E9%A2%98"><span class="toc-number">2.2.1.</span> <span class="toc-text">⭐ 序列化问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%B9%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">容器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#List"><span class="toc-number">3.1.</span> <span class="toc-text">List</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ArrayList-%E5%92%8C-LinkedList-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">3.1.1.</span> <span class="toc-text">ArrayList 和 LinkedList 有什么区别？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Map"><span class="toc-number">3.2.</span> <span class="toc-text">Map</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91"><span class="toc-number">4.</span> <span class="toc-text">并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E7%AE%80%E4%BB%8B"><span class="toc-number">4.1.</span> <span class="toc-text">并发简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">4.1.1.</span> <span class="toc-text">什么是进程？什么是线程？进程和线程的区别？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%EF%BC%88%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%89%E7%BC%96%E7%A8%8B%E7%9A%84%E5%A5%BD%E5%A4%84%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.1.2.</span> <span class="toc-text">并发（多线程）编程的好处是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E4%B8%80%E5%AE%9A%E6%AF%94%E4%B8%B2%E8%A1%8C%E6%9B%B4%E5%BF%AB%E5%90%97%EF%BC%9F"><span class="toc-number">4.1.3.</span> <span class="toc-text">并发一定比串行更快吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E8%AE%A9%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E7%9A%84%E7%BA%BF%E7%A8%8B%E6%9A%82%E5%81%9C%E4%B8%80%E6%AE%B5%E6%97%B6%E9%97%B4%EF%BC%9F"><span class="toc-number">4.1.4.</span> <span class="toc-text">如何让正在运行的线程暂停一段时间？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8-Thread-Scheduler-%E5%92%8C%E6%97%B6%E9%97%B4%E5%88%86%E7%89%87-Time-Slicing-%EF%BC%9F"><span class="toc-number">4.1.5.</span> <span class="toc-text">什么是线程调度器(Thread Scheduler)和时间分片(Time Slicing)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2-context-switching-%EF%BC%9F"><span class="toc-number">4.1.6.</span> <span class="toc-text">在多线程中，什么是上下文切换(context-switching)？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%A1%AE%E4%BF%9D%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-number">4.1.7.</span> <span class="toc-text">如何确保线程安全？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%BB%E9%94%81-Deadlock-%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%86%E6%9E%90%E5%92%8C%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%EF%BC%9F"><span class="toc-number">4.1.8.</span> <span class="toc-text">什么是死锁(Deadlock)？如何分析和避免死锁？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E5%9F%BA%E7%A1%80"><span class="toc-number">4.2.</span> <span class="toc-text">线程基础</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E7%BA%BF%E7%A8%8B%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%AD%E6%9C%89%E5%93%AA%E4%BA%9B%E7%8A%B6%E6%80%81%EF%BC%9F%E5%90%84%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E5%A6%82%E4%BD%95%E5%88%87%E6%8D%A2%EF%BC%9F"><span class="toc-number">4.2.1.</span> <span class="toc-text">Java 线程生命周期中有哪些状态？各状态之间如何切换？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E6%96%B9%E5%BC%8F%EF%BC%9F%E8%BF%99%E4%BA%9B%E6%96%B9%E6%B3%95%E5%90%84%E8%87%AA%E5%88%A9%E5%BC%8A%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.2.</span> <span class="toc-text">创建线程有哪些方式？这些方法各自利弊是什么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Callable-%E5%92%8C-Future%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF-FutureTask%EF%BC%9F"><span class="toc-number">4.2.3.</span> <span class="toc-text">什么是 Callable 和 Future？什么是 FutureTask？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#start-%E5%92%8C-run-%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E5%8F%AF%E4%BB%A5%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8-Thread-%E7%B1%BB%E7%9A%84-run-%E6%96%B9%E6%B3%95%E4%B9%88%EF%BC%9F"><span class="toc-number">4.2.4.</span> <span class="toc-text">start() 和 run() 有什么区别？可以直接调用 Thread 类的 run() 方法么？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sleep-%E3%80%81yield-%E3%80%81join-%E6%96%B9%E6%B3%95%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88-sleep-%E5%92%8C-yield-%E6%96%B9%E6%B3%95%E6%98%AF%E9%9D%99%E6%80%81%EF%BC%88static%EF%BC%89%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.5.</span> <span class="toc-text">sleep()、yield()、join() 方法有什么区别？为什么 sleep() 和 yield() 方法是静态（static）的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java-%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7%E5%A6%82%E4%BD%95%E6%8E%A7%E5%88%B6%EF%BC%9F%E9%AB%98%E4%BC%98%E5%85%88%E7%BA%A7%E7%9A%84-Java-%E7%BA%BF%E7%A8%8B%E4%B8%80%E5%AE%9A%E5%85%88%E6%89%A7%E8%A1%8C%E5%90%97%EF%BC%9F"><span class="toc-number">4.2.6.</span> <span class="toc-text">Java 的线程优先级如何控制？高优先级的 Java 线程一定先执行吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">4.2.7.</span> <span class="toc-text">什么是守护线程？为什么要用守护线程？如何创建守护线程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E6%98%AF%E5%A6%82%E4%BD%95%E9%80%9A%E4%BF%A1%E7%9A%84%EF%BC%9F"><span class="toc-number">4.2.8.</span> <span class="toc-text">线程间是如何通信的？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E6%96%B9%E6%B3%95-wait-notify-%E5%92%8C-notifyAll-%E8%A2%AB%E5%AE%9A%E4%B9%89%E5%9C%A8-Object-%E7%B1%BB%E9%87%8C%EF%BC%9F"><span class="toc-number">4.2.9.</span> <span class="toc-text">为什么线程通信的方法 wait(), notify() 和 notifyAll() 被定义在 Object 类里？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88-wait-notify-%E5%92%8C-notifyAll-%E5%BF%85%E9%A1%BB%E5%9C%A8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95%E6%88%96%E8%80%85%E5%90%8C%E6%AD%A5%E5%9D%97%E4%B8%AD%E8%A2%AB%E8%B0%83%E7%94%A8%EF%BC%9F"><span class="toc-number">4.2.10.</span> <span class="toc-text">为什么 wait(), notify() 和 notifyAll() 必须在同步方法或者同步块中被调用？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%9C%BA%E5%88%B6%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.3.</span> <span class="toc-text">并发机制的底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E2%AD%90-synchronized"><span class="toc-number">4.3.1.</span> <span class="toc-text">⭐⭐⭐ synchronized</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-volatile"><span class="toc-number">4.3.2.</span> <span class="toc-text">⭐ volatile</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-CAS"><span class="toc-number">4.3.3.</span> <span class="toc-text">⭐⭐ CAS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-ThreadLocal"><span class="toc-number">4.3.4.</span> <span class="toc-text">⭐ ThreadLocal</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.</span> <span class="toc-text">内存模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="toc-number">4.4.1.</span> <span class="toc-text">什么是 Java 内存模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8%E5%92%8C%E5%B9%B6%E5%8F%91%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.</span> <span class="toc-text">同步容器和并发容器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%90%8C%E6%AD%A5%E5%AE%B9%E5%99%A8"><span class="toc-number">4.5.1.</span> <span class="toc-text">⭐ 同步容器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90%E2%AD%90-ConcurrentHashMap"><span class="toc-number">4.5.2.</span> <span class="toc-text">⭐⭐⭐ ConcurrentHashMap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-CopyOnWriteArrayList"><span class="toc-number">4.5.3.</span> <span class="toc-text">⭐⭐ CopyOnWriteArrayList</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E9%94%81"><span class="toc-number">4.6.</span> <span class="toc-text">并发锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-%E9%94%81%E7%B1%BB%E5%9E%8B"><span class="toc-number">4.6.1.</span> <span class="toc-text">⭐⭐ 锁类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-AQS"><span class="toc-number">4.6.2.</span> <span class="toc-text">⭐⭐ AQS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-ReentrantLock"><span class="toc-number">4.6.3.</span> <span class="toc-text">⭐⭐ ReentrantLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-ReentrantReadWriteLock"><span class="toc-number">4.6.4.</span> <span class="toc-text">⭐ ReentrantReadWriteLock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-Condition"><span class="toc-number">4.6.5.</span> <span class="toc-text">⭐ Condition</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-%E6%AD%BB%E9%94%81"><span class="toc-number">4.6.6.</span> <span class="toc-text">⭐⭐ 死锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E5%8F%98%E9%87%8F%E7%B1%BB"><span class="toc-number">4.7.</span> <span class="toc-text">原子变量类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%AE%80%E4%BB%8B"><span class="toc-number">4.7.1.</span> <span class="toc-text">⭐ 原子类简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-%E5%8E%9F%E5%AD%90%E7%B1%BB%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">4.7.2.</span> <span class="toc-text">⭐ 原子类的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.8.</span> <span class="toc-text">并发工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-CountDownLatch"><span class="toc-number">4.8.1.</span> <span class="toc-text">⭐ CountDownLatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-CyclicBarrier"><span class="toc-number">4.8.2.</span> <span class="toc-text">⭐ CyclicBarrier</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-Semaphore"><span class="toc-number">4.8.3.</span> <span class="toc-text">⭐ Semaphore</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">4.9.</span> <span class="toc-text">线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90%E2%AD%90-ThreadPoolExecutor"><span class="toc-number">4.9.1.</span> <span class="toc-text">⭐⭐ ThreadPoolExecutor</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E2%AD%90-Executors"><span class="toc-number">4.9.2.</span> <span class="toc-text">⭐ Executors</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM"><span class="toc-number">5.</span> <span class="toc-text">JVM</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">类加载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.1.1.</span> <span class="toc-text">对象的创建过程了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM-%E9%87%8C-new-%E5%AF%B9%E8%B1%A1%E6%97%B6%EF%BC%8C%E5%A0%86%E4%BC%9A%E5%8F%91%E7%94%9F%E6%8A%A2%E5%8D%A0%E5%90%97%EF%BC%9FJVM%E6%98%AF%E6%80%8E%E4%B9%88%E8%AE%BE%E8%AE%A1%E6%9D%A5%E4%BF%9D%E8%AF%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84"><span class="toc-number">5.1.2.</span> <span class="toc-text">JVM 里 new 对象时，堆会发生抢占吗？JVM是怎么设计来保证线程安全的?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80"><span class="toc-number">5.1.3.</span> <span class="toc-text">对象的内存布局?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">内存管理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">5.2.1.</span> <span class="toc-text">对象内存分配方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E8%AF%B4%E4%B8%80%E4%B8%8BJVM%E7%9A%84%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E5%90%97%EF%BC%9F"><span class="toc-number">5.2.2.</span> <span class="toc-text">能说一下JVM的内存区域吗？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GC"><span class="toc-number">5.3.</span> <span class="toc-text">GC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E4%BB%8D%E7%84%B6%E5%AD%98%E6%B4%BB%EF%BC%9F"><span class="toc-number">5.3.1.</span> <span class="toc-text">如何判断对象仍然存活？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E7%AE%97%E6%B3%95%E4%BA%86%E8%A7%A3%E5%90%97%EF%BC%9F"><span class="toc-number">5.3.2.</span> <span class="toc-text">垃圾收集算法了解吗？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E5%8F%91%E6%A0%87%E8%AE%B0%E6%B8%85%E9%99%A4%E6%94%B6%E9%9B%86%E5%99%A8"><span class="toc-number">5.3.3.</span> <span class="toc-text">并发标记清除收集器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OOM"><span class="toc-number">5.4.</span> <span class="toc-text">OOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%8F%AF%E8%83%BD%E7%94%B1%E5%93%AA%E4%BA%9B%E5%8E%9F%E5%9B%A0%E5%AF%BC%E8%87%B4%E5%91%A2%EF%BC%9F"><span class="toc-number">5.4.1.</span> <span class="toc-text">内存泄漏可能由哪些原因导致呢？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%86%E8%A7%A3%E5%93%AA%E4%BA%9B%E6%80%A7JVM%E7%9B%91%E6%8E%A7%E5%92%8C%E6%95%85%E9%9A%9C%E5%A4%84%E7%90%86%E5%B7%A5%E5%85%B7%EF%BC%9F"><span class="toc-number">5.4.2.</span> <span class="toc-text">了解哪些性JVM监控和故障处理工具？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JVM%E7%9A%84%E5%B8%B8%E8%A7%81%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E7%9F%A5%E9%81%93%E5%93%AA%E4%BA%9B"><span class="toc-number">5.4.3.</span> <span class="toc-text">JVM的常见参数配置知道哪些?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E4%B8%8A%E6%9C%8D%E5%8A%A1CPU%E5%8D%A0%E7%94%A8%E8%BF%87%E9%AB%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">5.4.4.</span> <span class="toc-text">线上服务CPU占用过高怎么排查？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E9%A3%99%E9%AB%98%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E6%8E%92%E6%9F%A5%EF%BC%9F"><span class="toc-number">5.4.5.</span> <span class="toc-text">内存飙高问题怎么排查？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E7%B9%81-minor-gc-%E6%80%8E%E4%B9%88%E5%8A%9E%EF%BC%9F"><span class="toc-number">5.4.6.</span> <span class="toc-text">频繁 minor gc 怎么办？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E7%B9%81Full-GC%E6%80%8E%E4%B9%88%E5%8A%9E"><span class="toc-number">5.4.7.</span> <span class="toc-text">频繁Full GC怎么办</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E6%B2%A1%E6%9C%89%E5%A4%84%E7%90%86%E8%BF%87%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA-OOM-%E9%97%AE%E9%A2%98%EF%BC%9F%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9A%E4%BD%8D%E7%9A%84%EF%BC%9F"><span class="toc-number">5.4.8.</span> <span class="toc-text">有没有处理过内存溢出(OOM)问题？是如何定位的？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">6.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/4592b2fd" title="shell"><img src="https://prod-alicdn-community.kurobbs.com/forum/dcdad1b7aa454b97b412899068f94aa620250313.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="shell"/></a><div class="content"><a class="title" href="/posts/4592b2fd" title="shell">shell</a><time datetime="2025-11-16T06:52:35.000Z" title="发表于 2025-11-16 14:52:35">2025-11-16</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7ebb9be2" title="分布式基础"><img src="https://prod-alicdn-community.kurobbs.com/forum/5803ca9faed74b0080a1156e0ef93aae20250529.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="分布式基础"/></a><div class="content"><a class="title" href="/posts/7ebb9be2" title="分布式基础">分布式基础</a><time datetime="2025-11-04T00:15:33.000Z" title="发表于 2025-11-04 08:15:33">2025-11-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/c16f2ba9" title="ForkJoin框架"><img src="https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="ForkJoin框架"/></a><div class="content"><a class="title" href="/posts/c16f2ba9" title="ForkJoin框架">ForkJoin框架</a><time datetime="2025-10-18T07:27:46.000Z" title="发表于 2025-10-18 15:27:46">2025-10-18</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(https://prod-alicdn-community.kurobbs.com/forum/86e33bf60c4d48499faa119f83e96fa120250619.jpg?x-oss-process=image%2Fformat%2Cwebp);"><div class="footer-other"><div class="footer-copyright"><span class="copyright">&copy;2025 By coder-xuyong</span><span class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo 7.3.0</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly 5.4.2</a></span></div><div class="footer_custom_text">Hi, welcome to coder-xuyong's <a href="https://coder-xuyong.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i><!-- butterfly右下角悬浮菜单栏 百分比--><span id="percent">0</span></button><!-- butterfly右下角悬浮菜单栏 直达底部--><button id="go-down" type="button" title="直达底部" onclick="btf.scrollToDest(document.body.scrollHeight, 500)"><i class="fas fa-arrow-down"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><div class="js-pjax"><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.pageType === 'shuoshuo'
  const option = null

  const commentCount = n => {
    const isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
    if (isCommentCount) {
      isCommentCount.textContent= n
    }
  }

  const initGitalk = (el, path) => {
    if (isShuoshuo) {
      window.shuoshuoComment.destroyGitalk = () => {
        if (el.children.length) {
          el.innerHTML = ''
          el.classList.add('no-comment')
        }
      }
    }

    const gitalk = new Gitalk({
      clientID: 'Ov23li4gzANXxmx9072g',
      clientSecret: 'b4da9f4490b2864bfdee5df73655329a642c6112',
      repo: 'coder-xuyong.github.io',
      owner: 'coder-xuyong',
      admin: ['coder-xuyong'],
      updateCountCallback: commentCount,
      ...option,
      id: isShuoshuo ? path : (option && option.id) || '9961989efa80545c6791e60791dd7732'
    })

    gitalk.render('gitalk-container')
  }

  const loadGitalk = async(el, path) => {
    if (typeof Gitalk === 'function') initGitalk(el, path)
    else {
      await btf.getCSS('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css')
      await btf.getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js')
      initGitalk(el, path)
    }
  }

  if (isShuoshuo) {
    'Gitalk' === 'Gitalk'
      ? window.shuoshuoComment = { loadComment: loadGitalk }
      : window.loadOtherComment = loadGitalk
    return
  }

  if ('Gitalk' === 'Gitalk' || !true) {
    if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
    else loadGitalk()
  } else {
    window.loadOtherComment = loadGitalk
  }
})()</script></div><script src="/self/custom.js"></script><script defer="defer" id="ribbon" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-ribbon.min.js" size="150" alpha="0.6" zIndex="-1" mobile="false" data-click="true"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="https://cn.vercount.one/js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="search key word" type="text"/></div></div><hr/><div id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>